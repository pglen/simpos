     1                                  ; =============================================================================
     2                                  ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
     3                                  ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
     4                                  ;
     5                                  ; The BareMetal exokernel
     6                                  ; =============================================================================
     7                                  
     8                                  BITS 64					; Specify 64-bit
     9                                  ORG 0x0000000000100000			; The kernel needs to be loaded at this address
    10                                  
    11                                  ;%DEFINE BAREMETAL_VER 'v1.0.0 (January 21, 2020)', 13, 'Copyright (C) 2008-2020 Return Infinity', 13, 0
    12                                  ;%DEFINE BAREMETAL_API_VER 1
    13                                  
    14                                  KERNELSIZE equ 8192			; Pad the kernel to this length
    15                                  
    16                                  kernel_start:
    17 00000000 E90B010000              	jmp start			; Skip over the function call index
    18 00000005 90                      	nop
    19 00000006 53696D704F53202020      	db  'SimpOS   '	    ; Kernel signature
    20                                  
    21 0000000F 90                      align 16
    22 00000010 [6907000000000000]      	dq b_input			; 0x0010
    23 00000018 [8007000000000000]      	dq b_output			; 0x0018
    24 00000020 [CC07000000000000]      	dq b_net_tx			; 0x0020
    25 00000028 [1A08000000000000]      	dq b_net_rx			; 0x0028
    26 00000030 [E906000000000000]      	dq b_disk_read	    ; 0x0030
    27 00000038 [2907000000000000]      	dq b_disk_write	    ; 0x0038
    28 00000040 [2205000000000000]      	dq b_config			; 0x0040
    29 00000048 [7609000000000000]      	dq b_system			; 0x0048
    30 00000050 [0B02000000000000]          dq dummy_syscall	; 0x0050
    31 00000058 [0B02000000000000]          dq dummy_syscall	;
    32 00000060 [0B02000000000000]          dq dummy_syscall	;
    33 00000068 [0B02000000000000]          dq dummy_syscall	;
    34 00000070 [0B02000000000000]          dq dummy_syscall	;
    35 00000078 [0B02000000000000]          dq dummy_syscall	;
    36 00000080 [0B02000000000000]          dq dummy_syscall	;
    37 00000088 [0B02000000000000]          dq dummy_syscall	;
    38 00000090 [0B02000000000000]          dq dummy_syscall	;
    39 00000098 [0B02000000000000]          dq dummy_syscall	;
    40 000000A0 [0B02000000000000]          dq dummy_syscall	;
    41 000000A8 [0B02000000000000]          dq dummy_syscall	;
    42 000000B0 [0B02000000000000]          dq dummy_syscall	;
    43 000000B8 [0B02000000000000]          dq dummy_syscall	;
    44 000000C0 [0B02000000000000]          dq dummy_syscall	;
    45 000000C8 [0B02000000000000]          dq dummy_syscall	;
    46 000000D0 [0B02000000000000]          dq dummy_syscall	;
    47 000000D8 [0B02000000000000]          dq dummy_syscall	;
    48 000000E0 [0B02000000000000]          dq dummy_syscall	;
    49 000000E8 [0B02000000000000]          dq dummy_syscall	;
    50 000000F0 [0B02000000000000]          dq dummy_syscall	;
    51 000000F8 [0B02000000000000]          dq dummy_syscall	;
    52 00000100 [0B02000000000000]          dq dummy_syscall	;
    53 00000108 [0B02000000000000]          dq dummy_syscall	;
    54                                  
    55                                  align 16
    56                                  start:
    57 00000110 E827010000              	call init_64			; After this point we are in a working 64-bit environment
    58 00000115 E8E6020000              	call init_pci			; Initialize the PCI bus
    59 0000011A E8FC020000              	call init_hdd			; Initialize the disk
    60 0000011F E8FD020000              	call init_net			; Initialize the network
    61                                  
    62 00000124 48BE-                   	mov rsi, readymsg
    62 00000126 [9D17000000000000] 
    63 0000012E B90A000000              	mov rcx, 10
    64 00000133 E848060000              	call b_output
    65                                  
    66                                  	; Copy the payload after the kernel to the proper address
    67 00000138 BE00201000              	mov rsi, 0x100000 + KERNELSIZE	; Payload starts right after the kernel
    68 0000013D 48833E00                	cmp qword [rsi], 0		; Is there a payload after the kernel?
    69 00000141 741D                    	je ap_clear			; If not, skip to ap_clear
    70 00000143 BF00001E00              	mov rdi, 0x1E0000
    71 00000148 B900080000              	mov rcx, 2048
    72 0000014D F348A5                  	rep movsq			; Copy 16384 bytes
    73                                  
    74                                  	; Set the payload to run
    75 00000150 48C7042580001100-       	mov qword [os_ClockCallback], init_process
    75 00000158 [EC010000]         
    76                                  
    77                                  	; Fall through to ap_clear as align fills the space with No-Ops
    78                                  	; At this point the BSP is just like one of the AP's
    79                                  
    80 0000015C 90<rep 4h>              align 16
    81                                  ap_clear:				; All cores start here on first start-up and after an exception
    82 00000160 FA                      	cli				; Disable interrupts on this core
    83                                  
    84                                  	; Get local ID of the core
    85 00000161 488B342500001100        	mov rsi, [os_LocalAPICAddress]	; We can't use b_smp_get_id as no configured stack yet
    86 00000169 31C0                    	xor eax, eax			; Clear Task Priority (bits 7:4) and Task Priority Sub-Class (bits 3:0)
    87 0000016B 898680000000            	mov dword [rsi+0x80], eax	; APIC Task Priority Register (TPR)
    88 00000171 8B4620                  	mov eax, dword [rsi+0x20]	; APIC ID in upper 8 bits
    89 00000174 C1E818                  	shr eax, 24			; Shift to the right and AL now holds the CPU's APIC ID
    90 00000177 89C3                    	mov ebx, eax			; Save the APIC ID
    91                                  
    92                                  	; Set up the stack
    93 00000179 48C1E010                	shl rax, 16			; Shift left 16 bits for an 64 KiB stack
    94 0000017D 4803042528001100        	add rax, [os_StackBase]		; The stack decrements when you "push", start at 64 KiB in
    95 00000185 480500000100            	add rax, 65536
    96 0000018B 4889C4                  	mov rsp, rax
    97                                  
    98                                  	; Clear the entry in the work table
    99 0000018E 89D8                    	mov eax, ebx			; Restore the APIC ID
   100 00000190 BF00F81F00              	mov rdi, os_SMP
   101 00000195 48C1E003                	shl rax, 3			; Quick multiply by 8 to get to proper record
   102 00000199 4801C7                  	add rdi, rax
   103 0000019C 31C0                    	xor eax, eax
   104 0000019E 0C01                    	or al, 1			; Set bit 0 for "present"
   105 000001A0 48AB                    	stosq				; Clear the code address
   106                                  
   107                                  	; Clear registers. Gives us a clean slate to work with
   108 000001A2 31C0                    	xor eax, eax			; aka r0
   109 000001A4 31C9                    	xor ecx, ecx			; aka r1
   110 000001A6 31D2                    	xor edx, edx			; aka r2
   111 000001A8 31DB                    	xor ebx, ebx			; aka r3
   112 000001AA 31ED                    	xor ebp, ebp			; aka r5, We skip RSP (aka r4) as it was previously set
   113 000001AC 31F6                    	xor esi, esi			; aka r6
   114 000001AE 31FF                    	xor edi, edi			; aka r7
   115 000001B0 4D31C0                  	xor r8, r8
   116 000001B3 4D31C9                  	xor r9, r9
   117 000001B6 4D31D2                  	xor r10, r10
   118 000001B9 4D31DB                  	xor r11, r11
   119 000001BC 4D31E4                  	xor r12, r12
   120 000001BF 4D31ED                  	xor r13, r13
   121 000001C2 4D31F6                  	xor r14, r14
   122 000001C5 4D31FF                  	xor r15, r15
   123                                  
   124 000001C8 FB                      	sti				; Enable interrupts on this core
   125                                  
   126                                  ap_check:
   127 000001C9 E854070000              	call b_smp_get			; Check for an assigned workload
   128 000001CE 24F0                    	and al, 0xF0			; Clear the flags
   129 000001D0 4883F800                	cmp rax, 0			; If 0 then there is nothing to do
   130 000001D4 7503                    	jne ap_process
   131                                  
   132                                  ap_halt:				; Halt until a wakeup call is received
   133 000001D6 F4                      	hlt
   134 000001D7 EBF0                    	jmp ap_check			; Core will jump to ap_check when it wakes up
   135                                  
   136                                  ap_process:
   137 000001D9 B901000000              	mov rcx, 1			; Set the active flag
   138 000001DE E856070000              	call b_smp_setflag
   139 000001E3 31C9                    	xor ecx, ecx
   140 000001E5 FFD0                    	call rax			; Run the code
   141 000001E7 E974FFFFFF              	jmp ap_clear			; Reset the stack, clear the registers, and wait for something else to work on
   142                                  
   143                                  init_process:
   144 000001EC E8D8060000              	call b_smp_get_id		; Get the ID of the current core
   145 000001F1 4889C1                  	mov rcx, rax			; Copy the APIC ID for b_smp_set
   146 000001F4 B800001E00              	mov rax, 0x1E0000		; Payload was copied here
   147 000001F9 E8E1060000              	call b_smp_set
   148 000001FE 48C704258000110000-     	mov qword [os_ClockCallback], 0	; Clear the callback
   148 00000207 000000             
   149 0000020A C3                      	ret
   150                                  
   151                                  dummy_syscall:
   152                                  
   153 0000020B 56                          push rsi
   154 0000020C 51                          push rcx
   155 0000020D 48BE-                       mov rsi, dummymsg
   155 0000020F [2402000000000000] 
   156 00000217 B915000000              	mov rcx, 21
   157 0000021C E85F050000              	call b_output
   158 00000221 5E                          pop rsi
   159 00000222 59                          pop rcx
   160 00000223 C3                          ret
   161                                  
   162 00000224 43616C6C6564204475-     dummymsg:		db   'Called Dummy SysCall', 10, 0, 0, 0
   162 0000022D 6D6D79205379734361-
   162 00000236 6C6C0A000000       
   163                                  
   164                                  ; Includes
   165                                  %include "init.asm"
   166                              <1> ; =============================================================================
   167                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   168                              <1> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   169                              <1> ;
   170                              <1> ; Initialization Includes
   171                              <1> ; =============================================================================
   172                              <1> 
   173                              <1> 
   174                              <1> %include "init/64.asm"
   175                              <2> ; =============================================================================
   176                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   177                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   178                              <2> ;
   179                              <2> ; 64-bit initialization
   180                              <2> ; =============================================================================
   181                              <2> 
   182                              <2> 
   183                              <2> ; -----------------------------------------------------------------------------
   184                              <2> init_64:
   185                              <2> 	; Set the temporary stack
   186                              <2> 
   187                              <2> 	; Clear system variables area
   188 0000023C BF00001100          <2> 	mov edi, os_SystemVariables
   189 00000241 B900E00100          <2> 	mov ecx, 122880			; Clear 960 KiB
   190 00000246 31C0                <2> 	xor eax, eax
   191 00000248 F348AB              <2> 	rep stosq
   192                              <2> 
   193                              <2> 	; Create exception gate stubs (Pure64 has already set the correct gate markers)
   194 0000024B 31FF                <2> 	xor edi, edi			; 64-bit IDT at linear address 0x0000000000000000
   195 0000024D B920000000          <2> 	mov ecx, 32
   196 00000252 48B8-               <2> 	mov rax, exception_gate		; A generic exception handler
   196 00000254 [F811000000000000]  <2>
   197                              <2> make_exception_gate_stubs:
   198 0000025C E882010000          <2> 	call create_gate
   199 00000261 FFC7                <2> 	inc edi
   200 00000263 FFC9                <2> 	dec ecx
   201 00000265 75F5                <2> 	jnz make_exception_gate_stubs
   202                              <2> 
   203                              <2> 	; Set up the exception gates for all of the CPU exceptions
   204 00000267 31FF                <2> 	xor edi, edi
   205 00000269 B915000000          <2> 	mov ecx, 21
   206 0000026E 48B8-               <2> 	mov rax, exception_gate_00
   206 00000270 [0014000000000000]  <2>
   207                              <2> make_exception_gates:
   208 00000278 E866010000          <2> 	call create_gate
   209 0000027D FFC7                <2> 	inc edi
   210 0000027F 4883C018            <2> 	add rax, 24			; Each exception gate is 24 bytes
   211 00000283 48FFC9              <2> 	dec rcx
   212 00000286 75F0                <2> 	jnz make_exception_gates
   213                              <2> 
   214                              <2> 	; Create interrupt gate stubs (Pure64 has already set the correct gate markers)
   215 00000288 B9E0000000          <2> 	mov ecx, 256-32
   216 0000028D 48B8-               <2> 	mov rax, interrupt_gate
   216 0000028F [1812000000000000]  <2>
   217                              <2> make_interrupt_gate_stubs:
   218 00000297 E847010000          <2> 	call create_gate
   219 0000029C FFC7                <2> 	inc edi
   220 0000029E FFC9                <2> 	dec ecx
   221 000002A0 75F5                <2> 	jnz make_interrupt_gate_stubs
   222                              <2> 
   223                              <2> 	; Set up the IRQ handlers (Network IRQ handler is configured in init_net)
   224 000002A2 BF21000000          <2> 	mov edi, 0x21
   225 000002A7 48B8-               <2> 	mov rax, keyboard
   225 000002A9 [2012000000000000]  <2>
   226 000002B1 E82D010000          <2> 	call create_gate
   227 000002B6 BF22000000          <2> 	mov edi, 0x22
   228 000002BB 48B8-               <2> 	mov rax, cascade
   228 000002BD [A012000000000000]  <2>
   229 000002C5 E819010000          <2> 	call create_gate
   230 000002CA BF28000000          <2> 	mov edi, 0x28
   231 000002CF 48B8-               <2> 	mov rax, rtc
   231 000002D1 [A812000000000000]  <2>
   232 000002D9 E805010000          <2> 	call create_gate
   233 000002DE BF80000000          <2> 	mov edi, 0x80
   234 000002E3 48B8-               <2> 	mov rax, ap_wakeup
   234 000002E5 [C013000000000000]  <2>
   235 000002ED E8F1000000          <2> 	call create_gate
   236 000002F2 BF81000000          <2> 	mov edi, 0x81
   237 000002F7 48B8-               <2> 	mov rax, ap_reset
   237 000002F9 [D813000000000000]  <2>
   238 00000301 E8DD000000          <2> 	call create_gate
   239                              <2> 
   240                              <2> 	; Grab data from Pure64's infomap
   241 00000306 31C0                <2> 	xor eax, eax
   242 00000308 31DB                <2> 	xor ebx, ebx
   243 0000030A 31C9                <2> 	xor ecx, ecx
   244 0000030C BE08500000          <2> 	mov esi, 0x00005008
   245 00000311 AD                  <2> 	lodsd				; Load the BSP ID
   246 00000312 89C3                <2> 	mov ebx, eax			; Save it to EBX
   247 00000314 BE12500000          <2> 	mov esi, 0x00005012
   248 00000319 66AD                <2> 	lodsw				; Load the number of activated cores
   249 0000031B 6689C1              <2> 	mov cx, ax			; Save it to CX
   250 0000031E BE60500000          <2> 	mov esi, 0x00005060
   251 00000323 48AD                <2> 	lodsq
   252 00000325 4889042500001100    <2> 	mov [os_LocalAPICAddress], rax
   253 0000032D 48AD                <2> 	lodsq
   254 0000032F 4889042508001100    <2> 	mov [os_IOAPICAddress], rax
   255 00000337 BE10500000          <2> 	mov esi, 0x00005010
   256 0000033C 66AD                <2> 	lodsw
   257 0000033E 6689042502021100    <2> 	mov [os_CoreSpeed], ax
   258 00000346 BE12500000          <2> 	mov esi, 0x00005012
   259 0000034B 66AD                <2> 	lodsw
   260 0000034D 6689042500021100    <2> 	mov [os_NumCores], ax
   261 00000355 BE20500000          <2> 	mov esi, 0x00005020
   262 0000035A AD                  <2> 	lodsd
   263 0000035B 83E802              <2> 	sub eax, 2			; Save 2 MiB for the CPU stacks
   264 0000035E 50                  <2> 	push rax			; Save the free RAM size
   265 0000035F 89042508011100      <2> 	mov [os_MemAmount], eax		; In MiB's
   266 00000366 BE40500000          <2> 	mov esi, 0x00005040
   267 0000036B 48AD                <2> 	lodsq
   268 0000036D 4889042558001100    <2> 	mov [os_HPETAddress], rax
   269 00000375 58                  <2> 	pop rax				; Restore free RAM size
   270                              <2> 
   271                              <2> 	; Configure the Stack base
   272                              <2> 	; Take the last free page of RAM and remap it
   273 00000376 48C1E002            <2> 	shl rax, 2			; Quick multiply by 2
   274 0000037A 480500000200        <2> 	add rax, sys_pdh
   275 00000380 4889C6              <2> 	mov rsi, rax
   276 00000383 488B06              <2> 	mov rax, [rsi]
   277 00000386 48894608            <2> 	mov [rsi+8], rax
   278 0000038A 31C0                <2> 	xor eax, eax
   279 0000038C 488906              <2> 	mov [rsi], rax
   280 0000038F 48BB000000000080FF- <2> 	mov rbx, app_start
   280 00000398 FF                  <2>
   281 00000399 8B042508011100      <2> 	mov eax, [os_MemAmount]		; In MiB's
   282 000003A0 83C002              <2> 	add eax, 2
   283 000003A3 48C1E014            <2> 	shl rax, 20
   284 000003A7 4801D8              <2> 	add rax, rbx
   285 000003AA 4889042528001100    <2> 	mov [os_StackBase], rax
   286                              <2> 
   287                              <2> 	; Initialize all AP's to run our reset code. Skip the BSP
   288 000003B2 31C0                <2> 	xor eax, eax
   289 000003B4 BE00510000          <2> 	mov esi, 0x00005100		; Location in memory of the Pure64 CPU data
   290                              <2> next_ap:
   291 000003B9 6685C9              <2> 	test cx, cx
   292 000003BC 740F                <2> 	jz no_more_aps
   293 000003BE AC                  <2> 	lodsb				; Load the CPU APIC ID
   294 000003BF 38D8                <2> 	cmp al, bl
   295 000003C1 7405                <2> 	je skip_ap
   296 000003C3 E8A1040000          <2> 	call b_smp_reset		; Reset the CPU
   297                              <2> skip_ap:
   298 000003C8 66FFC9              <2> 	dec cx
   299 000003CB EBEC                <2> 	jmp next_ap
   300                              <2> no_more_aps:
   301                              <2> 
   302                              <2> 	; Enable specific interrupts
   303 000003CD B001                <2> 	mov al, 0x01			; Keyboard IRQ
   304 000003CF E8C9060000          <2> 	call os_pic_mask_clear
   305 000003D4 B002                <2> 	mov al, 0x02			; Cascade IRQ
   306 000003D6 E8C2060000          <2> 	call os_pic_mask_clear
   307 000003DB B008                <2> 	mov al, 0x08			; RTC IRQ
   308 000003DD E8BB060000          <2> 	call os_pic_mask_clear
   309                              <2> 
   310 000003E2 C3                  <2> 	ret
   311                              <2> ; -----------------------------------------------------------------------------
   312                              <2> 
   313                              <2> 
   314                              <2> ; -----------------------------------------------------------------------------
   315                              <2> ; create_gate
   316                              <2> ; rax = address of handler
   317                              <2> ; rdi = gate # to configure
   318                              <2> create_gate:
   319 000003E3 57                  <2> 	push rdi
   320 000003E4 50                  <2> 	push rax
   321                              <2> 
   322 000003E5 48C1E704            <2> 	shl rdi, 4			; Quickly multiply rdi by 16
   323 000003E9 66AB                <2> 	stosw				; Store the low word (15..0)
   324 000003EB 48C1E810            <2> 	shr rax, 16
   325 000003EF 4883C704            <2> 	add rdi, 4			; Skip the gate marker (selector, ist, type)
   326 000003F3 66AB                <2> 	stosw				; Store the high word (31..16)
   327 000003F5 48C1E810            <2> 	shr rax, 16
   328 000003F9 AB                  <2> 	stosd				; Store the high dword (63..32)
   329 000003FA 31C0                <2> 	xor eax, eax
   330 000003FC AB                  <2> 	stosd				; Reserved bits
   331                              <2> 
   332 000003FD 58                  <2> 	pop rax
   333 000003FE 5F                  <2> 	pop rdi
   334 000003FF C3                  <2> 	ret
   335                              <2> ; -----------------------------------------------------------------------------
   336                              <2> 
   337                              <2> 
   338                              <2> ; =============================================================================
   339                              <2> ; EOF
   175                              <1> %include "init/pci.asm"
   176                              <2> ; =============================================================================
   177                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   178                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   179                              <2> ;
   180                              <2> ; Initialize PCI
   181                              <2> ; =============================================================================
   182                              <2> 
   183                              <2> 
   184                              <2> ; -----------------------------------------------------------------------------
   185                              <2> init_pci:
   186 00000400 B800000080          <2> 	mov eax, 0x80000000
   187 00000405 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
   188 00000409 EF                  <2> 	out dx, eax
   189 0000040A ED                  <2> 	in eax, dx
   190 0000040B 3D00000080          <2> 	cmp eax, 0x80000000
   191 00000410 7508                <2> 	jne init_pci_not_found
   192 00000412 C604250703110001    <2> 	mov byte [os_PCIEnabled], 1
   193                              <2> 
   194                              <2> init_pci_not_found:
   195 0000041A C3                  <2> 	ret
   196                              <2> ; -----------------------------------------------------------------------------
   197                              <2> 
   198                              <2> 
   199                              <2> ; =============================================================================
   200                              <2> ; EOF
   176                              <1> %include "init/hdd.asm"
   177                              <2> ; =============================================================================
   178                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   179                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   180                              <2> ;
   181                              <2> ; Initialize disk
   182                              <2> ; =============================================================================
   183                              <2> 
   184                              <2> 
   185                              <2> ; -----------------------------------------------------------------------------
   186                              <2> init_hdd:
   187 0000041B E8A4060000          <2> 	call ahci_init
   188 00000420 C3                  <2> 	ret
   189                              <2> ; -----------------------------------------------------------------------------
   190                              <2> 
   191                              <2> 
   192                              <2> ; =============================================================================
   193                              <2> ; EOF
   177                              <1> %include "init/net.asm"
   178                              <2> ; =============================================================================
   179                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   180                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   181                              <2> ;
   182                              <2> ; Initialize network
   183                              <2> ; =============================================================================
   184                              <2> 
   185                              <2> 
   186                              <2> ; -----------------------------------------------------------------------------
   187                              <2> init_net:
   188                              <2> 	; Search for a supported NIC
   189 00000421 BA02000000          <2> 	mov edx, 0x00000002		; Register 2 for Class code/Subclass
   190                              <2> 
   191                              <2> init_net_probe_next:
   192 00000426 E834060000          <2> 	call os_pci_read
   193 0000042B C1E810              <2> 	shr eax, 16			; Move the Class/Subclass code to AX
   194 0000042E 663D0002            <2> 	cmp ax, 0x0200			; Network Controller (02) / Ethernet (00)
   195 00000432 7414                <2> 	je init_net_probe_find_driver	; Found a Network Controller... now search for a driver
   196 00000434 81C200010000        <2> 	add edx, 0x00000100		; Skip to next PCI device
   197 0000043A 81FA00FFFF00        <2> 	cmp edx, 0x00FFFF00		; Maximum of 65536 devices
   198 00000440 0F8DDB000000        <2> 	jge init_net_probe_not_found
   199 00000446 EBDE                <2> 	jmp init_net_probe_next
   200                              <2> 
   201                              <2> init_net_probe_find_driver:
   202 00000448 B200                <2> 	mov dl, 0x00			; Register 0 for Device/Vendor ID
   203 0000044A E810060000          <2> 	call os_pci_read		; Read the Device/Vendor ID from the PCI device
   204 0000044F 4189C0              <2> 	mov r8d, eax			; Save the Device/Vendor ID in R8D
   205 00000452 48BE-               <2> 	mov rsi, NIC_DeviceVendor_ID
   205 00000454 [4911000000000000]  <2>
   206 0000045C AD                  <2> 	lodsd				; Load a driver ID - Low half must be 0xFFFF
   207                              <2> init_net_probe_find_next_driver:
   208 0000045D 4889C3              <2> 	mov rbx, rax			; Save the driver ID
   209                              <2> init_net_probe_find_next_device:
   210 00000460 AD                  <2> 	lodsd				; Load a device and vendor ID from our list of supported NICs
   211 00000461 85C0                <2> 	test eax, eax			; 0x00000000 means we have reached the end of the list
   212 00000463 0F84B8000000        <2> 	jz init_net_probe_not_found	; No supported NIC found
   213 00000469 6683F8FF            <2> 	cmp ax, 0xFFFF			; New driver ID?
   214 0000046D 74EE                <2> 	je init_net_probe_find_next_driver	; We found the next driver type
   215 0000046F 4439C0              <2> 	cmp eax, r8d
   216 00000472 7402                <2> 	je init_net_probe_found		; If Carry is clear then we found a supported NIC
   217 00000474 EBEA                <2> 	jmp init_net_probe_find_next_device	; Check the next device
   218                              <2> 
   219                              <2> init_net_probe_found:
   220 00000476 81FBFFFF5482        <2> 	cmp ebx, 0x8254FFFF
   221 0000047C 740D                <2> 	je init_net_probe_found_i8254x
   222 0000047E 81FBFFFFF41A        <2> 	cmp ebx, 0x1AF4FFFF
   223 00000484 7435                <2> 	je init_net_probe_found_virtio
   224 00000486 E996000000          <2> 	jmp init_net_probe_not_found
   225                              <2> 
   226                              <2> init_net_probe_found_i8254x:
   227 0000048B E89D090000          <2> 	call net_i8254x_init
   228 00000490 BF30001100          <2> 	mov rdi, os_net_transmit
   229 00000495 48B8-               <2> 	mov rax, net_i8254x_transmit
   229 00000497 [4110000000000000]  <2>
   230 0000049F 48AB                <2> 	stosq
   231 000004A1 48B8-               <2> 	mov rax, net_i8254x_poll
   231 000004A3 [7C10000000000000]  <2>
   232 000004AB 48AB                <2> 	stosq
   233 000004AD 48B8-               <2> 	mov rax, net_i8254x_ack_int
   233 000004AF [BC10000000000000]  <2>
   234 000004B7 48AB                <2> 	stosq
   235 000004B9 EB30                <2> 	jmp init_net_probe_found_finish
   236                              <2> 
   237                              <2> init_net_probe_found_virtio:
   238 000004BB E80F0C0000          <2> 	call net_virtio_init
   239 000004C0 BF30001100          <2> 	mov rdi, os_net_transmit
   240 000004C5 48B8-               <2> 	mov rax, net_virtio_transmit
   240 000004C7 [4611000000000000]  <2>
   241 000004CF 48AB                <2> 	stosq
   242 000004D1 48B8-               <2> 	mov rax, net_virtio_poll
   242 000004D3 [4711000000000000]  <2>
   243 000004DB 48AB                <2> 	stosq
   244 000004DD 48B8-               <2> 	mov rax, net_virtio_ack_int
   244 000004DF [4811000000000000]  <2>
   245 000004E7 48AB                <2> 	stosq
   246 000004E9 EB00                <2> 	jmp init_net_probe_found_finish
   247                              <2> 
   248                              <2> init_net_probe_found_finish:
   249 000004EB 31C0                <2> 	xor eax, eax
   250 000004ED 8A04250A031100      <2> 	mov al, [os_NetIRQ]
   251                              <2> 
   252 000004F4 0420                <2> 	add al, 0x20
   253 000004F6 4889C7              <2> 	mov rdi, rax
   254 000004F9 48B8-               <2> 	mov rax, network
   254 000004FB [1013000000000000]  <2>
   255 00000503 E8DBFEFFFF          <2> 	call create_gate
   256                              <2> 
   257                              <2> 	; Enable the Network IRQ
   258 00000508 8A04250A031100      <2> 	mov al, [os_NetIRQ]
   259 0000050F E889050000          <2> 	call os_pic_mask_clear
   260                              <2> 
   261 00000514 C604250803110001    <2> 	mov byte [os_NetEnabled], 1	; A supported NIC was found. Signal to the OS that networking is enabled
   262 0000051C E827030000          <2> 	call b_net_ack_int		; Call the driver function to acknowledge the interrupt internally
   263                              <2> 
   264                              <2> init_net_probe_not_found:
   265                              <2> 
   266 00000521 C3                  <2> 	ret
   267                              <2> ; -----------------------------------------------------------------------------
   268                              <2> 
   269                              <2> 
   270                              <2> ; =============================================================================
   271                              <2> ; EOF
   178                              <1> 
   179                              <1> 
   180                              <1> ; =============================================================================
   181                              <1> ; EOF
   166                                  %include "syscalls.asm"
   167                              <1> ; =============================================================================
   168                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   169                              <1> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   170                              <1> ;
   171                              <1> ; System Call Section -- Accessible to user programs
   172                              <1> ; =============================================================================
   173                              <1> 
   174                              <1> 
   175                              <1> %include "syscalls/config.asm"
   176                              <2> ; =============================================================================
   177                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   178                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   179                              <2> ;
   180                              <2> ; Config Functions
   181                              <2> ; =============================================================================
   182                              <2> 
   183                              <2> 
   184                              <2> ; -----------------------------------------------------------------------------
   185                              <2> ; b_config - View or modify system configuration options
   186                              <2> ; IN:	RCX = Function
   187                              <2> ;	RAX = Variable 1
   188                              <2> ;	RDX = Variable 2
   189                              <2> ; OUT:	RAX = Result
   190                              <2> ;	All other registers preserved
   191                              <2> b_config:
   192 00000522 4883F900            <2> 	cmp rcx, 0
   193 00000526 7443                <2> 	je b_config_timecounter
   194 00000528 4883F901            <2> 	cmp rcx, 1
   195 0000052C 7446                <2> 	je b_config_smp_get_id
   196 0000052E 4883F903            <2> 	cmp rcx, 3
   197 00000532 7446                <2> 	je b_config_networkcallback_get
   198 00000534 4883F904            <2> 	cmp rcx, 4
   199 00000538 7449                <2> 	je b_config_networkcallback_set
   200 0000053A 4883F905            <2> 	cmp rcx, 5
   201 0000053E 744C                <2> 	je b_config_clockcallback_get
   202 00000540 4883F906            <2> 	cmp rcx, 6
   203 00000544 744F                <2> 	je b_config_clockcallback_set
   204 00000546 4883F91E            <2> 	cmp rcx, 30
   205 0000054A 7452                <2> 	je b_config_mac
   206                              <2> 	; PCI
   207 0000054C 4883F940            <2> 	cmp rcx, 0x40
   208 00000550 7452                <2> 	je b_config_pci_read
   209 00000552 4883F941            <2> 	cmp rcx, 0x41
   210 00000556 7452                <2> 	je b_config_pci_write
   211                              <2> 	; Standard Output
   212 00000558 4883F942            <2> 	cmp rcx, 0x42
   213 0000055C 745B                <2> 	je b_config_stdout_set
   214 0000055E 4883F943            <2> 	cmp rcx, 0x43
   215 00000562 744C                <2> 	je b_config_stdout_get
   216 00000564 4883F950            <2> 	cmp rcx, 0x50
   217 00000568 7458                <2> 	je b_config_drive_id
   218 0000056A C3                  <2> 	ret
   219                              <2> 
   220                              <2> b_config_timecounter:
   221 0000056B 488B042510001100    <2> 	mov rax, [os_ClockCounter]	; Grab the timer counter value. It increments 8 times a second
   222 00000573 C3                  <2> 	ret
   223                              <2> 
   224                              <2> b_config_smp_get_id:
   225 00000574 E850030000          <2> 	call b_smp_get_id
   226 00000579 C3                  <2> 	ret
   227                              <2> 
   228                              <2> b_config_networkcallback_get:
   229 0000057A 488B042568001100    <2> 	mov rax, [os_NetworkCallback]
   230 00000582 C3                  <2> 	ret
   231                              <2> 
   232                              <2> b_config_networkcallback_set:
   233 00000583 4889042568001100    <2> 	mov qword [os_NetworkCallback], rax
   234 0000058B C3                  <2> 	ret
   235                              <2> 
   236                              <2> b_config_clockcallback_get:
   237 0000058C 488B042580001100    <2> 	mov rax, [os_ClockCallback]
   238 00000594 C3                  <2> 	ret
   239                              <2> 
   240                              <2> b_config_clockcallback_set:
   241 00000595 4889042580001100    <2> 	mov qword [os_ClockCallback], rax
   242 0000059D C3                  <2> 	ret
   243                              <2> 
   244                              <2> b_config_mac:
   245 0000059E E801020000          <2> 	call b_net_status
   246 000005A3 C3                  <2> 	ret
   247                              <2> 
   248                              <2> b_config_pci_read:
   249 000005A4 E8B6040000          <2> 	call os_pci_read
   250 000005A9 C3                  <2> 	ret
   251                              <2> 
   252                              <2> b_config_pci_write:
   253 000005AA E8CE040000          <2> 	call os_pci_write
   254 000005AF C3                  <2> 	ret
   255                              <2> 
   256                              <2> b_config_stdout_get:
   257 000005B0 488B042518001000    <2> 	mov rax, qword [0x100018]
   258 000005B8 C3                  <2> 	ret
   259                              <2> 
   260                              <2> b_config_stdout_set:
   261 000005B9 4889042518001000    <2> 	mov qword [0x100018], rax
   262 000005C1 C3                  <2> 	ret
   263                              <2> 
   264                              <2> b_config_drive_id:
   265 000005C2 57                  <2> 	push rdi
   266 000005C3 4889C7              <2> 	mov rdi, rax
   267 000005C6 E8A8070000          <2> 	call ahci_id
   268 000005CB 5F                  <2> 	pop rdi
   269 000005CC C3                  <2> 	ret
   270                              <2> 
   271                              <2> ; -----------------------------------------------------------------------------
   272                              <2> 
   273                              <2> 
   274                              <2> ; =============================================================================
   275                              <2> ; EOF
   176                              <1> %include "syscalls/debug.asm"
   177                              <2> ; =============================================================================
   178                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   179                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   180                              <2> ;
   181                              <2> ; Debug Functions
   182                              <2> ; =============================================================================
   183                              <2> 
   184                              <2> 
   185                              <2> ; -----------------------------------------------------------------------------
   186                              <2> ; os_debug_dump_(rax|eax|ax|al) -- Dump content of RAX, EAX, AX, or AL
   187                              <2> ;  IN:	RAX = content to dump
   188                              <2> ; OUT:	Nothing, all registers preserved
   189                              <2> os_debug_dump_rax:
   190 000005CD 48C1C008            <2> 	rol rax, 8
   191 000005D1 E83F000000          <2> 	call os_debug_dump_al
   192 000005D6 48C1C008            <2> 	rol rax, 8
   193 000005DA E836000000          <2> 	call os_debug_dump_al
   194 000005DF 48C1C008            <2> 	rol rax, 8
   195 000005E3 E82D000000          <2> 	call os_debug_dump_al
   196 000005E8 48C1C008            <2> 	rol rax, 8
   197 000005EC E824000000          <2> 	call os_debug_dump_al
   198 000005F1 48C1C020            <2> 	rol rax, 32
   199                              <2> os_debug_dump_eax:
   200 000005F5 C1C008              <2> 	rol eax, 8
   201 000005F8 E818000000          <2> 	call os_debug_dump_al
   202 000005FD C1C008              <2> 	rol eax, 8
   203 00000600 E810000000          <2> 	call os_debug_dump_al
   204 00000605 C1C010              <2> 	rol eax, 16
   205                              <2> os_debug_dump_ax:
   206 00000608 66C1C008            <2> 	rol ax, 8
   207 0000060C E804000000          <2> 	call os_debug_dump_al
   208 00000611 66C1C008            <2> 	rol ax, 8
   209                              <2> os_debug_dump_al:
   210 00000615 53                  <2> 	push rbx
   211 00000616 50                  <2> 	push rax
   212 00000617 48BB-               <2> 	mov rbx, hextable
   212 00000619 [7F17000000000000]  <2>
   213 00000621 50                  <2> 	push rax			; Save RAX since we work in 2 parts
   214 00000622 C0E804              <2> 	shr al, 4			; Shift high 4 bits into low 4 bits
   215 00000625 D7                  <2> 	xlatb
   216 00000626 880425[56180000]    <2> 	mov [tchar+0], al
   217 0000062D 58                  <2> 	pop rax
   218 0000062E 240F                <2> 	and al, 0x0f			; Clear the high 4 bits
   219 00000630 D7                  <2> 	xlatb
   220 00000631 880425[57180000]    <2> 	mov [tchar+1], al
   221 00000638 56                  <2> 	push rsi
   222 00000639 51                  <2> 	push rcx
   223 0000063A 48BE-               <2> 	mov rsi, tchar
   223 0000063C [5618000000000000]  <2>
   224 00000644 B902000000          <2> 	mov rcx, 2
   225 00000649 E832010000          <2> 	call b_output
   226 0000064E 59                  <2> 	pop rcx
   227 0000064F 5E                  <2> 	pop rsi
   228 00000650 58                  <2> 	pop rax
   229 00000651 5B                  <2> 	pop rbx
   230 00000652 C3                  <2> 	ret
   231                              <2> ; -----------------------------------------------------------------------------
   232                              <2> 
   233                              <2> 
   234                              <2> ; -----------------------------------------------------------------------------
   235                              <2> ; os_debug_dump_mem -- Dump content of memory in hex format
   236                              <2> ;  IN:	RSI = starting address of memory to dump
   237                              <2> ;	RCX = number of bytes
   238                              <2> ; OUT:	Nothing, all registers preserved
   239                              <2> os_debug_dump_mem:
   240 00000653 56                  <2> 	push rsi
   241 00000654 51                  <2> 	push rcx			; Counter
   242 00000655 52                  <2> 	push rdx			; Total number of bytes to display
   243 00000656 50                  <2> 	push rax
   244                              <2> 
   245 00000657 4885C9              <2> 	test rcx, rcx			; Bail out if no bytes were requested
   246 0000065A 746B                <2> 	jz os_debug_dump_mem_done
   247                              <2> 
   248 0000065C 56                  <2> 	push rsi			; Output '0x'
   249 0000065D 51                  <2> 	push rcx
   250 0000065E 48BE-               <2> 	mov rsi, os_debug_dump_mem_chars
   250 00000660 [E506000000000000]  <2>
   251 00000668 B902000000          <2> 	mov rcx, 2
   252 0000066D E80E010000          <2> 	call b_output
   253 00000672 59                  <2> 	pop rcx
   254 00000673 5E                  <2> 	pop rsi
   255                              <2> 
   256 00000674 4889F0              <2> 	mov rax, rsi			; Output the memory address
   257 00000677 E851FFFFFF          <2> 	call os_debug_dump_rax
   258 0000067C E84B000000          <2> 	call os_debug_dump_mem_newline
   259                              <2> 
   260                              <2> nextline:
   261 00000681 66BA0000            <2> 	mov dx, 0
   262                              <2> nextchar:
   263 00000685 4883F900            <2> 	cmp rcx, 0
   264 00000689 7437                <2> 	je os_debug_dump_mem_done_newline
   265 0000068B 56                  <2> 	push rsi			; Output ' '
   266 0000068C 51                  <2> 	push rcx
   267 0000068D 48BE-               <2> 	mov rsi, os_debug_dump_mem_chars+3
   267 0000068F [E806000000000000]  <2>
   268 00000697 B901000000          <2> 	mov rcx, 1
   269 0000069C E8DF000000          <2> 	call b_output
   270 000006A1 59                  <2> 	pop rcx
   271 000006A2 5E                  <2> 	pop rsi
   272 000006A3 AC                  <2> 	lodsb
   273 000006A4 E86CFFFFFF          <2> 	call os_debug_dump_al
   274 000006A9 48FFC9              <2> 	dec rcx
   275 000006AC 48FFC2              <2> 	inc rdx
   276 000006AF 6683FA10            <2> 	cmp dx, 16			; End of line yet?
   277 000006B3 75D0                <2> 	jne nextchar
   278 000006B5 E812000000          <2> 	call os_debug_dump_mem_newline
   279 000006BA 4883F900            <2> 	cmp rcx, 0
   280 000006BE 7407                <2> 	je os_debug_dump_mem_done
   281 000006C0 EBBF                <2> 	jmp nextline
   282                              <2> 
   283                              <2>  os_debug_dump_mem_done_newline:
   284 000006C2 E805000000          <2> 	call os_debug_dump_mem_newline
   285                              <2> 
   286                              <2>  os_debug_dump_mem_done:
   287 000006C7 58                  <2> 	pop rax
   288 000006C8 59                  <2> 	pop rcx
   289 000006C9 5A                  <2> 	pop rdx
   290 000006CA 5E                  <2> 	pop rsi
   291 000006CB C3                  <2> 	ret
   292                              <2> 
   293                              <2>  os_debug_dump_mem_newline:
   294 000006CC 56                  <2> 	push rsi			; Output newline
   295 000006CD 51                  <2> 	push rcx
   296 000006CE 48BE-               <2> 	mov rsi, newline
   296 000006D0 [A617000000000000]  <2>
   297 000006D8 B901000000          <2> 	mov rcx, 1
   298 000006DD E89E000000          <2> 	call b_output
   299 000006E2 59                  <2> 	pop rcx
   300 000006E3 5E                  <2> 	pop rsi
   301 000006E4 C3                  <2> 	ret
   302                              <2> 
   303 000006E5 30783A20            <2> os_debug_dump_mem_chars: db '0x: '
   304                              <2> 
   305                              <2> 
   306                              <2> ; =============================================================================
   307                              <2> ; EOF
   177                              <1> %include "syscalls/disk.asm"
   178                              <2> ; =============================================================================
   179                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   180                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   181                              <2> ;
   182                              <2> ; Disk Block Storage Functions
   183                              <2> ; =============================================================================
   184                              <2> 
   185                              <2> 
   186                              <2> ; NOTE: BareMetal uses 4096 byte sectors.
   187                              <2> 
   188                              <2> 
   189                              <2> ; -----------------------------------------------------------------------------
   190                              <2> ; b_disk_read -- Read sectors from the disk
   191                              <2> ; IN:	RAX = Starting sector
   192                              <2> ;	RCX = Number of sectors to read
   193                              <2> ;	RDX = Disk
   194                              <2> ;	RDI = Memory location to store data
   195                              <2> ; OUT:	RCX = Number of sectors read
   196                              <2> ;	All other registers preserved
   197                              <2> b_disk_read:
   198 000006E9 57                  <2> 	push rdi
   199 000006EA 51                  <2> 	push rcx
   200 000006EB 50                  <2> 	push rax
   201                              <2> 
   202 000006EC 4883F900            <2> 	cmp rcx, 0
   203 000006F0 7431                <2> 	je b_disk_read_fail		; Bail out if instructed to read nothing
   204 000006F2 48C1E003            <2> 	shl rax, 3			; Convert to 512B starting sector
   205 000006F6 48C1E103            <2> 	shl rcx, 3			; Convert 4K sectors to 512B sectors
   206                              <2> 
   207                              <2> b_disk_read_loop:
   208 000006FA 4881F900200000      <2> 	cmp rcx, 8192			; We can read up to 8192 512B sectors with one call
   209 00000701 7C17                <2> 	jl b_disk_read_remainder
   210 00000703 51                  <2> 	push rcx
   211 00000704 B900200000          <2> 	mov rcx, 8192
   212 00000709 E89B040000          <2> 	call ahci_read
   213 0000070E 59                  <2> 	pop rcx
   214 0000070F 4881E900200000      <2> 	sub rcx, 8192
   215 00000716 75E2                <2> 	jnz b_disk_read_loop
   216 00000718 EB05                <2> 	jmp b_disk_read_done
   217                              <2> b_disk_read_remainder:
   218 0000071A E88A040000          <2> 	call ahci_read
   219                              <2> 
   220                              <2> b_disk_read_done:
   221 0000071F 58                  <2> 	pop rax
   222 00000720 59                  <2> 	pop rcx
   223 00000721 5F                  <2> 	pop rdi
   224 00000722 C3                  <2> 	ret
   225                              <2> 
   226                              <2> b_disk_read_fail:
   227 00000723 58                  <2> 	pop rax
   228 00000724 59                  <2> 	pop rcx
   229 00000725 5F                  <2> 	pop rdi
   230 00000726 31C9                <2> 	xor ecx, ecx
   231 00000728 C3                  <2> 	ret
   232                              <2> ; -----------------------------------------------------------------------------
   233                              <2> 
   234                              <2> 
   235                              <2> ; -----------------------------------------------------------------------------
   236                              <2> ; b_disk_write -- Write sectors to the disk
   237                              <2> ; IN:	RAX = Starting sector
   238                              <2> ;	RCX = Number of sectors to write
   239                              <2> ;	RDX = Disk
   240                              <2> ;	RSI = Memory location of data
   241                              <2> ; OUT:	RCX = Number of sectors written
   242                              <2> ;	All other registers preserved
   243                              <2> b_disk_write:
   244 00000729 56                  <2> 	push rsi
   245 0000072A 51                  <2> 	push rcx
   246 0000072B 50                  <2> 	push rax
   247                              <2> 
   248 0000072C 4883F900            <2> 	cmp rcx, 0
   249 00000730 7431                <2> 	je b_disk_write_fail		; Bail out if instructed to write nothing
   250 00000732 48C1E003            <2> 	shl rax, 3			; Convert to 512B starting sector
   251 00000736 48C1E103            <2> 	shl rcx, 3			; Convert 4K sectors to 512B sectors
   252                              <2> 
   253                              <2> b_disk_write_loop:
   254 0000073A 4881F900200000      <2> 	cmp rcx, 8192			; We can write up to 8192 512B sectors with one call
   255 00000741 7C17                <2> 	jl b_disk_write_remainder
   256 00000743 51                  <2> 	push rcx
   257 00000744 B900200000          <2> 	mov rcx, 8192
   258 00000749 E840050000          <2> 	call ahci_write
   259 0000074E 59                  <2> 	pop rcx
   260 0000074F 4881E900200000      <2> 	sub rcx, 8192
   261 00000756 75E2                <2> 	jnz b_disk_write_loop
   262 00000758 EB05                <2> 	jmp b_disk_write_done
   263                              <2> b_disk_write_remainder:
   264 0000075A E82F050000          <2> 	call ahci_write
   265                              <2> 
   266                              <2> b_disk_write_done:
   267 0000075F 58                  <2> 	pop rax
   268 00000760 59                  <2> 	pop rcx
   269 00000761 5E                  <2> 	pop rsi
   270 00000762 C3                  <2> 	ret
   271                              <2> 
   272                              <2> b_disk_write_fail:
   273 00000763 58                  <2> 	pop rax
   274 00000764 59                  <2> 	pop rcx
   275 00000765 5E                  <2> 	pop rsi
   276 00000766 31C9                <2> 	xor ecx, ecx
   277 00000768 C3                  <2> 	ret
   278                              <2> ; -----------------------------------------------------------------------------
   279                              <2> 
   280                              <2> 
   281                              <2> ; =============================================================================
   282                              <2> ; EOF
   178                              <1> %include "syscalls/io.asm"
   179                              <2> ; =============================================================================
   180                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   181                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   182                              <2> ;
   183                              <2> ; Input/Output Functions
   184                              <2> ; =============================================================================
   185                              <2> 
   186                              <2> 
   187                              <2> ; -----------------------------------------------------------------------------
   188                              <2> ; b_input -- Scans keyboard for input
   189                              <2> ;  IN:	Nothing
   190                              <2> ; OUT:	AL = 0 if no key pressed, otherwise ASCII code, other regs preserved
   191                              <2> ;	Carry flag is set if there was a keystroke, clear if there was not
   192                              <2> ;	All other registers preserved
   193                              <2> b_input:
   194 00000769 8A042503031100      <2> 	mov al, [key]
   195 00000770 84C0                <2> 	test al, al
   196 00000772 740A                <2> 	jz b_input_no_key
   197 00000774 C604250303110000    <2> 	mov byte [key], 0x00		; clear the variable as the keystroke is in AL now
   198 0000077C F9                  <2> 	stc				; set the carry flag
   199 0000077D C3                  <2> 	ret
   200                              <2> 
   201                              <2> b_input_no_key:
   202 0000077E F8                  <2> 	clc				; clear the carry flag
   203 0000077F C3                  <2> 	ret
   204                              <2> ; -----------------------------------------------------------------------------
   205                              <2> 
   206                              <2> 
   207                              <2> ; -----------------------------------------------------------------------------
   208                              <2> ; b_output -- Outputs characters
   209                              <2> ;  IN:	RSI = message location (non zero-terminated)
   210                              <2> ;	RCX = number of chars to output
   211                              <2> ; OUT:	All registers preserved
   212                              <2> b_output:
   213 00000780 56                  <2> 	push rsi			; Message location
   214 00000781 52                  <2> 	push rdx			; Serial port address
   215 00000782 51                  <2> 	push rcx			; Counter of chars left to output
   216 00000783 50                  <2> 	push rax			; AL is used for the serial port output
   217                              <2> 
   218 00000784 FC                  <2> 	cld				    ; Clear the direction flag.. we want to increment through the string
   219 00000785 66BAF803            <2> 	mov dx, 0x03F8	    ; Address of first serial port
   220                              <2> 
   221                              <2> b_output_nextchar:
   222 00000789 E314                <2> 	jrcxz b_output_done		; If RCX is 0 then the function is complete
   223 0000078B 6683C205            <2> 	add dx, 5			; Offset to Line Status Register
   224 0000078F EC                  <2> 	in al, dx
   225 00000790 6683EA05            <2> 	sub dx, 5			; Back to to base
   226 00000794 3C00                <2> 	cmp al, 0
   227 00000796 74F1                <2> 	je b_output_nextchar
   228 00000798 48FFC9              <2> 	dec rcx
   229 0000079B AC                  <2> 	lodsb				; Get char from string and store in AL
   230 0000079C EE                  <2> 	out dx, al			; Send the char to the serial port
   231 0000079D EBEA                <2> 	jmp b_output_nextchar
   232                              <2> 
   233                              <2> b_output_done:
   234 0000079F 58                  <2> 	pop rax
   235 000007A0 59                  <2> 	pop rcx
   236 000007A1 5A                  <2> 	pop rdx
   237 000007A2 5E                  <2> 	pop rsi
   238 000007A3 C3                  <2> 	ret
   239                              <2> ; -----------------------------------------------------------------------------
   240                              <2> 
   241                              <2> 
   242                              <2> ; =============================================================================
   243                              <2> ; EOF
   179                              <1> %include "syscalls/net.asm"
   180                              <2> ; =============================================================================
   181                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   182                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   183                              <2> ;
   184                              <2> ; Network Functions
   185                              <2> ; =============================================================================
   186                              <2> 
   187                              <2> 
   188                              <2> ; -----------------------------------------------------------------------------
   189                              <2> ; b_net_status -- Check if network access is available
   190                              <2> ;  IN:	Nothing
   191                              <2> ; OUT:	RAX = MAC Address if net is enabled, otherwise 0
   192                              <2> b_net_status:
   193 000007A4 56                  <2> 	push rsi
   194 000007A5 51                  <2> 	push rcx
   195                              <2> 
   196 000007A6 FC                  <2> 	cld
   197 000007A7 31C0                <2> 	xor eax, eax
   198 000007A9 803C250803110000    <2> 	cmp byte [os_NetEnabled], 0
   199 000007B1 7416                <2> 	je b_net_status_end
   200                              <2> 
   201 000007B3 B906000000          <2> 	mov ecx, 6
   202 000007B8 BE50001100          <2> 	mov rsi, os_NetMAC
   203                              <2> b_net_status_loadMAC:
   204 000007BD 48C1E008            <2> 	shl rax, 8
   205 000007C1 AC                  <2> 	lodsb
   206 000007C2 83E901              <2> 	sub ecx, 1
   207 000007C5 85C9                <2> 	test ecx, ecx
   208 000007C7 75F4                <2> 	jnz b_net_status_loadMAC
   209                              <2> 
   210                              <2> b_net_status_end:
   211 000007C9 59                  <2> 	pop rcx
   212 000007CA 5E                  <2> 	pop rsi
   213 000007CB C3                  <2> 	ret
   214                              <2> ; -----------------------------------------------------------------------------
   215                              <2> 
   216                              <2> 
   217                              <2> ; -----------------------------------------------------------------------------
   218                              <2> ; b_net_tx -- Transmit a packet via the network
   219                              <2> ;  IN:	RSI = Memory location where packet is stored
   220                              <2> ;	RCX = Length of packet
   221                              <2> ; OUT:	Nothing. All registers preserved
   222                              <2> b_net_tx:
   223 000007CC 51                  <2> 	push rcx
   224 000007CD 50                  <2> 	push rax
   225                              <2> 
   226 000007CE 803C250803110001    <2> 	cmp byte [os_NetEnabled], 1	; Check if networking is enabled
   227 000007D6 753F                <2> 	jne b_net_tx_fail
   228 000007D8 4883F940            <2> 	cmp rcx, 64			; An net packet must be at least 64 bytes
   229 000007DC 7D05                <2> 	jge b_net_tx_maxcheck
   230 000007DE B940000000          <2> 	mov rcx, 64			; If it was below 64 then set to 64
   231                              <2> 	; FIXME - OS should pad the packet with 0's before sending if less than 64
   232                              <2> 
   233                              <2> b_net_tx_maxcheck:
   234 000007E3 4881F9F2050000      <2> 	cmp rcx, 1522			; Fail if more than 1522 bytes
   235 000007EA 7F2B                <2> 	jg b_net_tx_fail
   236                              <2> 
   237 000007EC B80C021100          <2> 	mov rax, os_NetLock		; Lock the net so only one send can happen at a time
   238 000007F1 E86A010000          <2> 	call b_smp_lock
   239                              <2> 
   240 000007F6 48FF042590001100    <2> 	inc qword [os_net_TXPackets]
   241 000007FE 48010C2588001100    <2> 	add qword [os_net_TXBytes], rcx
   242 00000806 FF142530001100      <2> 	call qword [os_net_transmit]	; Call the driver
   243                              <2> 
   244 0000080D B80C021100          <2> 	mov rax, os_NetLock
   245 00000812 E859010000          <2> 	call b_smp_unlock
   246                              <2> 
   247                              <2> b_net_tx_fail:
   248 00000817 58                  <2> 	pop rax
   249 00000818 59                  <2> 	pop rcx
   250 00000819 C3                  <2> 	ret
   251                              <2> ; -----------------------------------------------------------------------------
   252                              <2> 
   253                              <2> 
   254                              <2> ; -----------------------------------------------------------------------------
   255                              <2> ; b_net_rx -- Polls the network for received data
   256                              <2> ;  IN:	RDI = Memory location where packet will be stored
   257                              <2> ; OUT:	RCX = Length of packet, 0 if no data
   258                              <2> ;	All other registers preserved
   259                              <2> b_net_rx:
   260 0000081A 57                  <2> 	push rdi
   261 0000081B 56                  <2> 	push rsi
   262 0000081C 50                  <2> 	push rax
   263                              <2> 
   264 0000081D 31C9                <2> 	xor ecx, ecx
   265                              <2> 
   266 0000081F 803C250803110001    <2> 	cmp byte [os_NetEnabled], 1
   267 00000827 751B                <2> 	jne b_net_rx_fail
   268                              <2> 
   269 00000829 BE00001B00          <2> 	mov rsi, os_PacketBuffers	; Packet exists here
   270 0000082E 668B06              <2> 	mov ax, word [rsi]		; Grab the packet length
   271 00000831 6685C0              <2> 	test ax, ax			; Anything there?
   272 00000834 740E                <2> 	jz b_net_rx_fail		; If not, bail out
   273 00000836 66890E              <2> 	mov word [rsi], cx		; Clear the packet length
   274 00000839 6689C1              <2> 	mov cx, ax			; Save the count
   275 0000083C 4883C602            <2> 	add rsi, 2			; Skip the packet length word
   276 00000840 51                  <2> 	push rcx
   277 00000841 F3A4                <2> 	rep movsb			; Copy packet to new memory
   278 00000843 59                  <2> 	pop rcx
   279                              <2> 
   280                              <2> b_net_rx_fail:
   281                              <2> 
   282 00000844 58                  <2> 	pop rax
   283 00000845 5E                  <2> 	pop rsi
   284 00000846 5F                  <2> 	pop rdi
   285 00000847 C3                  <2> 	ret
   286                              <2> ; -----------------------------------------------------------------------------
   287                              <2> 
   288                              <2> 
   289                              <2> ; -----------------------------------------------------------------------------
   290                              <2> ; b_net_ack_int -- Acknowledge an interrupt within the NIC
   291                              <2> ;  IN:	Nothing
   292                              <2> ; OUT:	RAX = Type of interrupt trigger
   293                              <2> ;	All other registers preserved
   294                              <2> b_net_ack_int:
   295 00000848 FF142540001100      <2> 	call qword [os_net_ackint]
   296                              <2> 
   297 0000084F C3                  <2> 	ret
   298                              <2> ; -----------------------------------------------------------------------------
   299                              <2> 
   300                              <2> 
   301                              <2> ; -----------------------------------------------------------------------------
   302                              <2> ; b_net_rx_from_interrupt -- Polls the network for received data
   303                              <2> ;  IN:	RDI = Memory location where packet will be stored
   304                              <2> ; OUT:	RCX = Length of packet
   305                              <2> ;	All other registers preserved
   306                              <2> b_net_rx_from_interrupt:
   307 00000850 FF142538001100      <2> 	call qword [os_net_poll]	; Call the driver
   308 00000857 48830425A000110001  <2> 	add qword [os_net_RXPackets], 1
   309 00000860 48010C2598001100    <2> 	add qword [os_net_RXBytes], rcx
   310                              <2> 
   311 00000868 C3                  <2> 	ret
   312                              <2> ; -----------------------------------------------------------------------------
   313                              <2> 
   314                              <2> 
   315                              <2> ; =============================================================================
   316                              <2> ; EOF
   180                              <1> %include "syscalls/smp.asm"
   181                              <2> ; =============================================================================
   182                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   183                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   184                              <2> ;
   185                              <2> ; SMP Functions
   186                              <2> ; =============================================================================
   187                              <2> 
   188                              <2> 
   189                              <2> ; -----------------------------------------------------------------------------
   190                              <2> ; b_smp_reset -- Resets a CPU Core
   191                              <2> ;  IN:	AL = CPU #
   192                              <2> ; OUT:	Nothing. All registers preserved.
   193                              <2> ; Note:	This code resets an AP for set-up use only.
   194                              <2> b_smp_reset:
   195 00000869 57                  <2> 	push rdi
   196 0000086A 50                  <2> 	push rax
   197                              <2> 
   198 0000086B 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
   199 00000873 C1E018              <2> 	shl eax, 24		; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
   200 00000876 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
   201 0000087C 31C0                <2> 	xor eax, eax		; Clear EAX, namely bits 31:24
   202 0000087E B081                <2> 	mov al, 0x81		; Execute interrupt 0x81
   203 00000880 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
   204                              <2> 
   205 00000886 58                  <2> 	pop rax
   206 00000887 5F                  <2> 	pop rdi
   207 00000888 C3                  <2> 	ret
   208                              <2> ; -----------------------------------------------------------------------------
   209                              <2> 
   210                              <2> 
   211                              <2> ; -----------------------------------------------------------------------------
   212                              <2> ; b_smp_wakeup -- Wake up a CPU Core
   213                              <2> ;  IN:	AL = CPU #
   214                              <2> ; OUT:	Nothing. All registers preserved.
   215                              <2> b_smp_wakeup:
   216 00000889 57                  <2> 	push rdi
   217 0000088A 50                  <2> 	push rax
   218                              <2> 
   219 0000088B 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
   220 00000893 C1E018              <2> 	shl eax, 24		; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
   221 00000896 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
   222 0000089C 31C0                <2> 	xor eax, eax		; Clear EAX, namely bits 31:24
   223 0000089E B080                <2> 	mov al, 0x80		; Execute interrupt 0x80
   224 000008A0 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
   225                              <2> 
   226 000008A6 58                  <2> 	pop rax
   227 000008A7 5F                  <2> 	pop rdi
   228 000008A8 C3                  <2> 	ret
   229                              <2> ; -----------------------------------------------------------------------------
   230                              <2> 
   231                              <2> 
   232                              <2> ; -----------------------------------------------------------------------------
   233                              <2> ; b_smp_wakeup_all -- Wake up all CPU Cores
   234                              <2> ;  IN:	Nothing.
   235                              <2> ; OUT:	Nothing. All registers preserved.
   236                              <2> b_smp_wakeup_all:
   237 000008A9 57                  <2> 	push rdi
   238 000008AA 50                  <2> 	push rax
   239                              <2> 
   240 000008AB 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
   241 000008B3 31C0                <2> 	xor eax, eax
   242 000008B5 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
   243 000008BB B880000C00          <2> 	mov eax, 0x000C0080	; Execute interrupt 0x80
   244 000008C0 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
   245                              <2> 
   246 000008C6 58                  <2> 	pop rax
   247 000008C7 5F                  <2> 	pop rdi
   248 000008C8 C3                  <2> 	ret
   249                              <2> ; -----------------------------------------------------------------------------
   250                              <2> 
   251                              <2> 
   252                              <2> ; -----------------------------------------------------------------------------
   253                              <2> ; b_smp_get_id -- Returns the APIC ID of the CPU that ran this function
   254                              <2> ;  IN:	Nothing
   255                              <2> ; OUT:	RAX = CPU's APIC ID number, All other registers preserved.
   256                              <2> b_smp_get_id:
   257 000008C9 56                  <2> 	push rsi
   258                              <2> 
   259 000008CA 31C0                <2> 	xor eax, eax
   260 000008CC 488B342500001100    <2> 	mov rsi, [os_LocalAPICAddress]
   261 000008D4 4883C620            <2> 	add rsi, 0x20		; Add the offset for the APIC ID location
   262 000008D8 AD                  <2> 	lodsd			; APIC ID is stored in bits 31:24
   263 000008D9 48C1E818            <2> 	shr rax, 24		; AL now holds the CPU's APIC ID (0 - 255)
   264                              <2> 
   265 000008DD 5E                  <2> 	pop rsi
   266 000008DE C3                  <2> 	ret
   267                              <2> ; -----------------------------------------------------------------------------
   268                              <2> 
   269                              <2> 
   270                              <2> ; -----------------------------------------------------------------------------
   271                              <2> ; b_smp_set -- Set a specific CPU to run code
   272                              <2> ;  IN:	RAX = Code address
   273                              <2> ;	RCX = CPU APIC ID
   274                              <2> ; OUT:	RAX = 0 on error
   275                              <2> ; Note:	Code address must be 16-byte aligned
   276                              <2> b_smp_set:
   277 000008DF 57                  <2> 	push rdi
   278 000008E0 50                  <2> 	push rax
   279 000008E1 51                  <2> 	push rcx		; Save the APIC ID
   280 000008E2 50                  <2> 	push rax		; Save the code address
   281                              <2> 
   282 000008E3 BF00F81F00          <2> 	mov rdi, os_SMP
   283 000008E8 48C1E103            <2> 	shl rcx, 3		; Quick multiply by 8
   284 000008EC 4801CF              <2> 	add rdi, rcx		; Add the offset
   285 000008EF 488B0F              <2> 	mov rcx, [rdi]		; Load current value for that core
   286                              <2> 
   287 000008F2 660FBAE100          <2> 	bt cx, 0		; Check for "present" flag
   288 000008F7 7322                <2> 	jnc b_smp_set_error	; Bail out if 0
   289                              <2> 
   290 000008F9 80E1F0              <2> 	and cl, 0xF0		; Clear the flags from the value in table
   291 000008FC 4883F900            <2> 	cmp rcx, 0		; Is there already a code address set?
   292 00000900 7519                <2> 	jne b_smp_set_error	; Bail out if the core is already set
   293                              <2> 
   294 00000902 240F                <2> 	and al, 0x0F		; Keep only the lower 4 bits
   295 00000904 3C00                <2> 	cmp al, 0		; Are the lower 4 bits of the code address set to 0?
   296 00000906 7513                <2> 	jne b_smp_set_error	; Bail out if not as the code address isn't properly aligned
   297                              <2> 
   298 00000908 58                  <2> 	pop rax			; Restore the code address
   299 00000909 0C01                <2> 	or al, 0x01		; Make sure the present flag is set
   300 0000090B 488907              <2> 	mov [rdi], rax		; Store code address
   301                              <2> 
   302 0000090E 59                  <2> 	pop rcx			; Restore the APIC ID
   303 0000090F 4891                <2> 	xchg rax, rcx
   304 00000911 E873FFFFFF          <2> 	call b_smp_wakeup	; Wake up the core
   305 00000916 4891                <2> 	xchg rax, rcx
   306                              <2> 
   307 00000918 58                  <2> 	pop rax
   308 00000919 5F                  <2> 	pop rdi
   309 0000091A C3                  <2> 	ret
   310                              <2> 
   311                              <2> b_smp_set_error:
   312 0000091B 58                  <2> 	pop rax
   313 0000091C 31C0                <2> 	xor eax, eax		; Return 0 for error
   314 0000091E 59                  <2> 	pop rcx
   315 0000091F 58                  <2> 	pop rax
   316 00000920 5F                  <2> 	pop rdi
   317 00000921 C3                  <2> 	ret
   318                              <2> ; -----------------------------------------------------------------------------
   319                              <2> 
   320                              <2> 
   321                              <2> ; -----------------------------------------------------------------------------
   322                              <2> ; b_smp_get -- Returns a CPU code address and flags
   323                              <2> ;  IN:	Nothing
   324                              <2> ; OUT:	RAX = Code address (bits 63:4) and flags (bits 3:0)
   325                              <2> b_smp_get:
   326 00000922 56                  <2> 	push rsi
   327                              <2> 
   328 00000923 E8A1FFFFFF          <2> 	call b_smp_get_id	; Return APIC ID in RAX
   329                              <2> 
   330 00000928 BE00F81F00          <2> 	mov rsi, os_SMP
   331 0000092D 48C1E003            <2> 	shl rax, 3		; Quick multiply by 8
   332 00000931 4801C6              <2> 	add rsi, rax		; Add the offset
   333 00000934 488B06              <2> 	mov rax, [rsi]		; Load code address and flags
   334 00000937 5E                  <2> 	pop rsi
   335 00000938 C3                  <2> 	ret
   336                              <2> ; -----------------------------------------------------------------------------
   337                              <2> 
   338                              <2> 
   339                              <2> ; -----------------------------------------------------------------------------
   340                              <2> ; b_smp_setflag -- Set a CPU flag
   341                              <2> ;  IN:	RCX = Flag #
   342                              <2> ; OUT:	Nothing
   343                              <2> b_smp_setflag:
   344 00000939 56                  <2> 	push rsi
   345 0000093A 50                  <2> 	push rax
   346                              <2> 
   347 0000093B 4883F904            <2> 	cmp rcx, 4		; If a value higher than 3 was chosen then bail out
   348 0000093F 7D1B                <2> 	jge b_smp_setflag_done
   349                              <2> 
   350 00000941 E883FFFFFF          <2> 	call b_smp_get_id	; Return APIC ID in RAX
   351                              <2> 
   352 00000946 BE00F81F00          <2> 	mov rsi, os_SMP
   353 0000094B 48C1E003            <2> 	shl rax, 3		; Quick multiply by 8
   354 0000094F 4801C6              <2> 	add rsi, rax		; Add the offset
   355 00000952 488B06              <2> 	mov rax, [rsi]		; Load code address and flags
   356 00000955 480FABC8            <2> 	bts rax, rcx		; Set the flag
   357 00000959 488906              <2> 	mov [rsi], rax		; Store the code address and new flags
   358                              <2> 
   359                              <2> b_smp_setflag_done:
   360 0000095C 58                  <2> 	pop rax
   361 0000095D 5E                  <2> 	pop rsi
   362 0000095E C3                  <2> 	ret
   363                              <2> ; -----------------------------------------------------------------------------
   364                              <2> 
   365                              <2> 
   366                              <2> ; -----------------------------------------------------------------------------
   367                              <2> ; b_smp_config -- Just a stub for now
   368                              <2> ;  IN:	Nothing
   369                              <2> ; OUT:	Nothing. All registers preserved.
   370                              <2> b_smp_config:
   371 0000095F C3                  <2> 	ret
   372                              <2> ; -----------------------------------------------------------------------------
   373                              <2> 
   374                              <2> 
   375                              <2> ; -----------------------------------------------------------------------------
   376                              <2> ; b_smp_lock -- Attempt to lock a mutex
   377                              <2> ;  IN:	RAX = Address of lock variable
   378                              <2> ; OUT:	Nothing. All registers preserved.
   379                              <2> b_smp_lock:
   380 00000960 660FBA2000          <2> 	bt word [rax], 0	; Check if the mutex is free (Bit 0 cleared to 0)
   381 00000965 72F9                <2> 	jc b_smp_lock		; If not check it again
   382 00000967 F0660FBA2800        <2> 	lock bts word [rax], 0	; The mutex was free, lock the bus. Try to grab the mutex
   383 0000096D 72F1                <2> 	jc b_smp_lock		; Jump if we were unsuccessful
   384 0000096F C3                  <2> 	ret			; Lock acquired. Return to the caller
   385                              <2> ; -----------------------------------------------------------------------------
   386                              <2> 
   387                              <2> 
   388                              <2> ; -----------------------------------------------------------------------------
   389                              <2> ; b_smp_unlock -- Unlock a mutex
   390                              <2> ;  IN:	RAX = Address of lock variable
   391                              <2> ; OUT:	Nothing. All registers preserved.
   392                              <2> b_smp_unlock:
   393 00000970 660FBA3000          <2> 	btr word [rax], 0	; Release the lock (Bit 0 cleared to 0)
   394 00000975 C3                  <2> 	ret			; Lock released. Return to the caller
   395                              <2> ; -----------------------------------------------------------------------------
   396                              <2> 
   397                              <2> 
   398                              <2> ; =============================================================================
   399                              <2> ; EOF
   181                              <1> %include "syscalls/system.asm"
   182                              <2> ; =============================================================================
   183                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   184                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   185                              <2> ;
   186                              <2> ; System Functions
   187                              <2> ; =============================================================================
   188                              <2> 
   189                              <2> 
   190                              <2> ; -----------------------------------------------------------------------------
   191                              <2> ; b_system - Call misc OS sub-functions
   192                              <2> ; IN:	RCX = Function
   193                              <2> ;	RAX = Variable 1
   194                              <2> ;	RDX = Variable 2
   195                              <2> ; OUT:	RAX = Result 1, dependant on system call
   196                              <2> ;	RDX = Result 2, dependant on system call
   197                              <2> b_system:
   198                              <2> ;	cmp rcx, X
   199                              <2> ;	je b_system_
   200 00000976 4883F902            <2> 	cmp rcx, 2
   201 0000097A 743A                <2> 	je b_system_smp_lock
   202 0000097C 4883F903            <2> 	cmp rcx, 3
   203 00000980 743A                <2> 	je b_system_smp_unlock
   204 00000982 4883F904            <2> 	cmp rcx, 4
   205 00000986 743A                <2> 	je b_system_debug_dump_mem
   206 00000988 4883F905            <2> 	cmp rcx, 5
   207 0000098C 7444                <2> 	je b_system_debug_dump_rax
   208 0000098E 4883F906            <2> 	cmp rcx, 6
   209 00000992 7444                <2> 	je b_system_delay
   210 00000994 4883F907            <2> 	cmp rcx, 7
   211 00000998 7444                <2> 	je b_system_ethernet_status
   212 0000099A 4883F908            <2> 	cmp rcx, 8
   213 0000099E 7444                <2> 	je b_system_mem_get_free
   214 000009A0 4883F909            <2> 	cmp rcx, 9
   215 000009A4 7448                <2> 	je b_system_smp_numcores
   216 000009A6 4883F90A            <2> 	cmp rcx, 10
   217 000009AA 744D                <2> 	je b_system_smp_set
   218 000009AC 4881F900010000      <2> 	cmp rcx, 256
   219 000009B3 744F                <2> 	je b_system_reset
   220 000009B5 C3                  <2> 	ret
   221                              <2> 
   222                              <2> b_system_smp_lock:
   223 000009B6 E8A5FFFFFF          <2> 	call b_smp_lock
   224 000009BB C3                  <2> 	ret
   225                              <2> 
   226                              <2> b_system_smp_unlock:
   227 000009BC E8AFFFFFFF          <2> 	call b_smp_unlock
   228 000009C1 C3                  <2> 	ret
   229                              <2> 
   230                              <2> b_system_debug_dump_mem:
   231 000009C2 56                  <2> 	push rsi
   232 000009C3 51                  <2> 	push rcx
   233 000009C4 4889C6              <2> 	mov rsi, rax
   234 000009C7 4889D1              <2> 	mov rcx, rdx
   235 000009CA E884FCFFFF          <2> 	call os_debug_dump_mem
   236 000009CF 59                  <2> 	pop rcx
   237 000009D0 5E                  <2> 	pop rsi
   238 000009D1 C3                  <2> 	ret
   239                              <2> 
   240                              <2> b_system_debug_dump_rax:
   241 000009D2 E8F6FBFFFF          <2> 	call os_debug_dump_rax
   242 000009D7 C3                  <2> 	ret
   243                              <2> 
   244                              <2> b_system_delay:
   245 000009D8 E85C000000          <2> 	call os_delay
   246 000009DD C3                  <2> 	ret
   247                              <2> 
   248                              <2> b_system_ethernet_status:
   249 000009DE E8C1FDFFFF          <2> 	call b_net_status
   250 000009E3 C3                  <2> 	ret
   251                              <2> 
   252                              <2> b_system_mem_get_free:
   253 000009E4 31C0                <2> 	xor eax, eax
   254 000009E6 8B042508011100      <2> 	mov eax, [os_MemAmount]
   255 000009ED C3                  <2> 	ret
   256                              <2> 
   257                              <2> b_system_smp_numcores:
   258 000009EE 31C0                <2> 	xor eax, eax
   259 000009F0 668B042500021100    <2> 	mov ax, [os_NumCores]
   260 000009F8 C3                  <2> 	ret
   261                              <2> 
   262                              <2> b_system_smp_set:
   263 000009F9 51                  <2> 	push rcx
   264 000009FA 4889D1              <2> 	mov rcx, rdx
   265 000009FD E8DDFEFFFF          <2> 	call b_smp_set
   266 00000A02 59                  <2> 	pop rcx
   267 00000A03 C3                  <2> 	ret
   268                              <2> 
   269                              <2> b_system_reset:
   270 00000A04 31C0                <2> 	xor eax, eax
   271 00000A06 4889042568001100    <2> 	mov qword [os_NetworkCallback], rax	; clear callbacks
   272 00000A0E 4889042580001100    <2> 	mov qword [os_ClockCallback], rax
   273 00000A16 E8AEFEFFFF          <2> 	call b_smp_get_id		; Reset all other cpu cores
   274 00000A1B 4889C3              <2> 	mov rbx, rax
   275 00000A1E BE00510000          <2> 	mov rsi, 0x0000000000005100	; Location in memory of the Pure64 CPU data
   276                              <2>  b_system_reset_next_ap:
   277 00000A23 6685C9              <2> 	test cx, cx
   278 00000A26 740F                <2> 	jz b_system_reset_no_more_aps
   279 00000A28 AC                  <2> 	lodsb				; Load the CPU APIC ID
   280 00000A29 38D8                <2> 	cmp al, bl
   281 00000A2B 7405                <2> 	je b_system_reset_skip_ap
   282 00000A2D E837FEFFFF          <2> 	call b_smp_reset		; Reset the CPU
   283                              <2>  b_system_reset_skip_ap:
   284 00000A32 66FFC9              <2> 	dec cx
   285 00000A35 EBEC                <2> 	jmp b_system_reset_next_ap
   286                              <2>  b_system_reset_no_more_aps:
   287 00000A37 CD81                <2> 	int 0x81			; Reset this core
   288                              <2> ; -----------------------------------------------------------------------------
   289                              <2> 
   290                              <2> 
   291                              <2> ; -----------------------------------------------------------------------------
   292                              <2> ; os_delay -- Delay by X eights of a second
   293                              <2> ; IN:	RAX = Time in eights of a second
   294                              <2> ; OUT:	All registers preserved
   295                              <2> ; A value of 8 in RAX will delay 1 second and a value of 1 will delay 1/8 of a second
   296                              <2> ; This function depends on the RTC (IRQ 8) so interrupts must be enabled.
   297                              <2> os_delay:
   298 00000A39 51                  <2> 	push rcx
   299 00000A3A 50                  <2> 	push rax
   300                              <2> 
   301 00000A3B 488B0C2510001100    <2> 	mov rcx, [os_ClockCounter]	; Grab the initial timer counter. It increments 8 times a second
   302 00000A43 4801C8              <2> 	add rax, rcx			; Add RCX so we get the end time we want
   303                              <2>  os_delay_loop:
   304 00000A46 4839042510001100    <2> 	cmp qword [os_ClockCounter], rax	; Compare it against our end time
   305 00000A4E 7EF6                <2> 	jle os_delay_loop		; Loop if RAX is still lower
   306                              <2> 
   307 00000A50 58                  <2> 	pop rax
   308 00000A51 59                  <2> 	pop rcx
   309 00000A52 C3                  <2> 	ret
   310                              <2> ; -----------------------------------------------------------------------------
   311                              <2> 
   312                              <2> 
   313                              <2> ; -----------------------------------------------------------------------------
   314                              <2> ; reboot -- Reboot the computer
   315                              <2> reboot:
   316 00000A53 E464                <2> 	in al, 0x64
   317 00000A55 A802                <2> 	test al, 00000010b		; Wait for an empty Input Buffer
   318 00000A57 75FA                <2> 	jne reboot
   319 00000A59 B0FE                <2> 	mov al, 0xFE
   320 00000A5B E664                <2> 	out 0x64, al			; Send the reboot call to the keyboard controller
   321 00000A5D EBF4                <2> 	jmp reboot
   322                              <2> ; -----------------------------------------------------------------------------
   323                              <2> 
   324                              <2> 
   325                              <2> ; =============================================================================
   326                              <2> ; EOF
   182                              <1> 
   183                              <1> 
   184                              <1> ; =============================================================================
   185                              <1> ; EOF
   167                                  %include "drivers.asm"
   168                              <1> ; =============================================================================
   169                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   170                              <1> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   171                              <1> ;
   172                              <1> ; Driver Includes
   173                              <1> ; =============================================================================
   174                              <1> 
   175                              <1> 
   176                              <1> ; Internal
   177                              <1> %include "drivers/pci.asm"
   178                              <2> ; =============================================================================
   179                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   180                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   181                              <2> ;
   182                              <2> ; PCI Functions
   183                              <2> ; =============================================================================
   184                              <2> 
   185                              <2> 
   186                              <2> ; The PCI functions below require the bus ID, device/function ID, and register
   187                              <2> ; ID to be passed in EDX as shown below:
   188                              <2> ;
   189                              <2> ; 0x 00 BS DF RG
   190                              <2> ; BS = Bus, 8 bits
   191                              <2> ; DF = Device/Function, 8 bits
   192                              <2> ; RG = Register, 8 bits, 6 used, upper 2 bits will be cleared if set
   193                              <2> 
   194                              <2> 
   195                              <2> ; -----------------------------------------------------------------------------
   196                              <2> ; os_pci_read -- Read from a register on a PCI device
   197                              <2> ;  IN:	EDX = Register to read from
   198                              <2> ; OUT:	EAX = Register value that was read
   199                              <2> ;	All other registers preserved
   200                              <2> os_pci_read:
   201 00000A5F 52                  <2> 	push rdx
   202                              <2> 
   203 00000A60 C0E202              <2> 	shl dl, 2			; Shift PCI register ID left two bits
   204 00000A63 81E2FCFFFF00        <2> 	and edx, 0x00FFFFFC		; Clear bits 31 - 24, 1 - 0
   205 00000A69 81CA00000080        <2> 	or edx, 0x80000000		; Set bit 31
   206 00000A6F 89D0                <2> 	mov eax, edx			; We need dx so save value to EAX for use
   207                              <2> 
   208 00000A71 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
   209 00000A75 EF                  <2> 	out dx, eax
   210 00000A76 66BAFC0C            <2> 	mov dx, PCI_CONFIG_DATA
   211 00000A7A ED                  <2> 	in eax, dx
   212                              <2> 
   213 00000A7B 5A                  <2> 	pop rdx
   214 00000A7C C3                  <2> 	ret
   215                              <2> ; -----------------------------------------------------------------------------
   216                              <2> 
   217                              <2> 
   218                              <2> ; -----------------------------------------------------------------------------
   219                              <2> ; os_pci_write -- Write to a register on a PCI device
   220                              <2> ;  IN:	EDX = Register to write to
   221                              <2> ;	EAX = Register value to be written
   222                              <2> ; OUT:	Nothing, all registers preserved
   223                              <2> os_pci_write:
   224 00000A7D 52                  <2> 	push rdx
   225 00000A7E 50                  <2> 	push rax			; Save the value to be written
   226                              <2> 
   227 00000A7F C0E202              <2> 	shl dl, 2			; Shift PCI register ID left two bits
   228 00000A82 81E2FCFFFF00        <2> 	and edx, 0x00FFFFFC		; Clear bits 31 - 24, 1 - 0
   229 00000A88 81CA00000080        <2> 	or edx, 0x80000000		; Set bit 31
   230 00000A8E 89D0                <2> 	mov eax, edx			; We need dx so save value to EAX for use
   231                              <2> 
   232 00000A90 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
   233 00000A94 EF                  <2> 	out dx, eax
   234 00000A95 58                  <2> 	pop rax				; Restore the value and write it
   235 00000A96 66BAFC0C            <2> 	mov dx, PCI_CONFIG_DATA
   236 00000A9A EF                  <2> 	out dx, eax
   237                              <2> 
   238 00000A9B 5A                  <2> 	pop rdx
   239 00000A9C C3                  <2> 	ret
   240                              <2> ; -----------------------------------------------------------------------------
   241                              <2> 
   242                              <2> 
   243                              <2> ; Configuration Mechanism One has two IO port rages associated with it.
   244                              <2> ; The address port (0xCF8-0xCFB) and the data port (0xCFC-0xCFF).
   245                              <2> ; A configuration cycle consists of writing to the address port to specify which device and register you want to access and then reading or writing the data to the data port.
   246                              <2> 
   247                              <2> PCI_CONFIG_ADDRESS	EQU	0x0CF8
   248                              <2> PCI_CONFIG_DATA		EQU	0x0CFC
   249                              <2> 
   250                              <2> ; Address dd 10000000000000000000000000000000b
   251                              <2> ;            /\     /\      /\   /\ /\    /;           E  Res    Bus     Dev  F  Reg   0
   253                              <2> ; Bits
   254                              <2> ; 31		Enable bit = set to 1
   255                              <2> ; 30 - 24	Reserved = set to 0
   256                              <2> ; 23 - 16	Bus number = 256 options
   257                              <2> ; 15 - 11	Device/Slot number = 32 options
   258                              <2> ; 10 - 8	Function number = will leave at 0 (8 options)
   259                              <2> ; 7 - 2		Register number = will leave at 0 (64 options) 64 x 4 bytes = 256 bytes worth of accessible registers
   260                              <2> ; 1 - 0		Set to 0
   261                              <2> 
   262                              <2> 
   263                              <2> ; =============================================================================
   264                              <2> ; EOF
   178                              <1> %include "drivers/pic.asm"
   179                              <2> ; =============================================================================
   180                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   181                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   182                              <2> ;
   183                              <2> ; PIC Functions
   184                              <2> ; =============================================================================
   185                              <2> 
   186                              <2> 
   187                              <2> ; -----------------------------------------------------------------------------
   188                              <2> ; os_pic_mask_clear -- Clear a mask on the PIC
   189                              <2> ;  IN:	AL  = IRQ #
   190                              <2> ; OUT:	All registers preserved
   191                              <2> os_pic_mask_clear:
   192 00000A9D 6652                <2> 	push dx
   193 00000A9F 6653                <2> 	push bx
   194 00000AA1 6650                <2> 	push ax
   195                              <2> 
   196 00000AA3 88C3                <2> 	mov bl, al			; Save the IRQ value
   197 00000AA5 80FB08              <2> 	cmp bl, 8			; Less than 8
   198 00000AA8 7C09                <2> 	jl os_pic_mask_clear_low	; If so, only set Master PIC
   199 00000AAA 66BAA100            <2> 	mov dx, 0xA1			; Slave PIC data address
   200 00000AAE 80EB08              <2> 	sub bl, 8
   201 00000AB1 EB04                <2> 	jmp os_pic_mask_clear_write
   202                              <2> os_pic_mask_clear_low:
   203 00000AB3 66BA2100            <2> 	mov dx, 0x21			; Mast PIC data address
   204                              <2> os_pic_mask_clear_write:
   205 00000AB7 EC                  <2> 	in al, dx			; Read the current mask
   206 00000AB8 660FB3D8            <2> 	btr ax, bx
   207 00000ABC EE                  <2> 	out dx, al			; Write the new mask
   208                              <2> 
   209 00000ABD 6658                <2> 	pop ax
   210 00000ABF 665B                <2> 	pop bx
   211 00000AC1 665A                <2> 	pop dx
   212 00000AC3 C3                  <2> ret
   213                              <2> ; -----------------------------------------------------------------------------
   214                              <2> 
   215                              <2> 
   216                              <2> ; =============================================================================
   217                              <2> ; EOF
   179                              <1> 
   180                              <1> ; Storage
   181                              <1> %include "drivers/storage/ahci.asm"
   182                              <2> ; =============================================================================
   183                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   184                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   185                              <2> ;
   186                              <2> ; AHCI Driver
   187                              <2> ; =============================================================================
   188                              <2> 
   189                              <2> 
   190                              <2> ; -----------------------------------------------------------------------------
   191                              <2> ahci_init:
   192                              <2> 	; Probe for an AHCI hard drive controller
   193 00000AC4 BA02000000          <2> 	mov edx, 0x00000002		; Start at register 2 of the first device
   194                              <2> 
   195                              <2> ahci_init_probe_next:
   196 00000AC9 E891FFFFFF          <2> 	call os_pci_read
   197 00000ACE C1E810              <2> 	shr eax, 16			; Move the Class/Subclass code to AX
   198 00000AD1 663D0601            <2> 	cmp ax, 0x0106			; Mass Storage Controller (01) / SATA Controller (06)
   199 00000AD5 7414                <2> 	je ahci_init_found		; Found a SATA Controller
   200 00000AD7 81C200010000        <2> 	add edx, 0x00000100		; Skip to next PCI device
   201 00000ADD 81FA00FFFF00        <2> 	cmp edx, 0x00FFFF00		; Maximum of 65536 devices
   202 00000AE3 0F8DBF000000        <2> 	jge ahci_init_not_found
   203 00000AE9 EBDE                <2> 	jmp ahci_init_probe_next
   204                              <2> 
   205                              <2> ahci_init_found:
   206 00000AEB B209                <2> 	mov dl, 9
   207 00000AED 31C0                <2> 	xor eax, eax
   208 00000AEF E86BFFFFFF          <2> 	call os_pci_read		; BAR5 (AHCI Base Address Register)
   209 00000AF4 4889042560001100    <2> 	mov [ahci_base], rax
   210 00000AFC 4889C6              <2> 	mov rsi, rax			; RSI holds the ABAR
   211                              <2> 
   212                              <2> ; Enable AHCI
   213 00000AFF 31C0                <2> 	xor eax, eax
   214 00000B01 0FBAE81F            <2> 	bts eax, 31
   215 00000B05 894604              <2> 	mov [rsi+AHCI_GHC], eax
   216                              <2> 
   217                              <2> ; Search the implemented ports for connected devices
   218 00000B08 8B560C              <2> 	mov edx, [rsi+AHCI_PI]		; PI – Ports Implemented
   219 00000B0B 31C9                <2> 	xor ecx, ecx
   220                              <2> ahci_init_search_ports:
   221 00000B0D 83F920              <2> 	cmp ecx, 32			; Maximum number of AHCI ports
   222 00000B10 7426                <2> 	je ahci_init_search_ports_done
   223 00000B12 0FA3CA              <2> 	bt edx, ecx			; Is this port marked as implemented?
   224 00000B15 731C                <2> 	jnc ahci_init_skip_port		; If not, skip it
   225                              <2> 
   226 00000B17 89CB                <2> 	mov ebx, ecx			; Copy current port
   227 00000B19 C1E307              <2> 	shl ebx, 7			; Multiply by 128 (0x80) for start of port registers
   228 00000B1C 81C328010000        <2> 	add ebx, 0x128			; Add 0x100 port registers and 0x28 for PxSSTS
   229                              <2> 
   230 00000B22 8B041E              <2> 	mov eax, [rsi+rbx]
   231 00000B25 240F                <2> 	and al, 0x0F			; Keep bits 3-0
   232 00000B27 3C03                <2> 	cmp al, 0x03			; Check if device is present and comm enabled
   233 00000B29 7508                <2> 	jne ahci_init_skip_port		; If not skip the port
   234                              <2> 
   235 00000B2B 0FAB0C250C011100    <2> 	bts dword [ahci_PA], ecx	; Set the port # as active
   236                              <2> 
   237                              <2> ahci_init_skip_port:
   238 00000B33 48FFC1              <2> 	inc rcx
   239 00000B36 EBD5                <2> 	jmp ahci_init_search_ports
   240                              <2> 
   241                              <2> ahci_init_search_ports_done:
   242                              <2> 
   243                              <2> ; Configure the active ports
   244 00000B38 8B14250C011100      <2> 	mov edx, [ahci_PA]
   245 00000B3F 31C9                <2> 	xor ecx, ecx
   246                              <2> ahci_init_config_active:
   247 00000B41 83F920              <2> 	cmp ecx, 32			; Maximum number of AHCI ports
   248 00000B44 7462                <2> 	je ahci_init_config_active_done
   249 00000B46 0FA3CA              <2> 	bt edx, ecx			; Is this port marked as active?
   250 00000B49 7358                <2> 	jnc ahci_init_config_active_skip
   251                              <2> 
   252 00000B4B 4889F7              <2> 	mov rdi, rsi			; RSI holds the AHCI Base address
   253 00000B4E 4881C700010000      <2> 	add rdi, 0x100			; Offset to port 0
   254 00000B55 48C1E107            <2> 	shl rcx, 7			; Quick multiply by 0x80
   255 00000B59 4801CF              <2> 	add rdi, rcx
   256 00000B5C 48C1E907            <2> 	shr rcx, 7
   257                              <2> 
   258 00000B60 8B4718              <2> 	mov eax, [rdi+AHCI_PxCMD]	; Stop the port
   259 00000B63 0FBAF004            <2> 	btr eax, 4			; FRE
   260 00000B67 0FBAF000            <2> 	btr eax, 0			; ST
   261 00000B6B 894718              <2> 	mov [rdi+AHCI_PxCMD], eax
   262                              <2> 
   263 00000B6E 31C0                <2> 	xor eax, eax
   264 00000B70 894738              <2> 	mov [rdi+AHCI_PxCI], eax	; Clear all command slots
   265                              <2> 
   266 00000B73 B800001400          <2> 	mov rax, ahci_CLB		; Command List (1K with 32 entries, 32 bytes each)
   267 00000B78 48C1E10A            <2> 	shl rcx, 10
   268 00000B7C 4801C8              <2> 	add rax, rcx			; Add offset to base
   269 00000B7F 48C1E90A            <2> 	shr rcx, 10
   270 00000B83 AB                  <2> 	stosd				; Offset 00h: PxCLB – Port x Command List Base Address
   271 00000B84 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
   272 00000B88 AB                  <2> 	stosd				; Offset 04h: PxCLBU – Port x Command List Base Address Upper 32-bits
   273                              <2> 
   274 00000B89 B800801400          <2> 	mov rax, ahci_FB		; Received FIS (4096 bytes per port)
   275 00000B8E 48C1E10C            <2> 	shl rcx, 12
   276 00000B92 4801C8              <2> 	add rax, rcx			; Add offset to base
   277 00000B95 48C1E90C            <2> 	shr rcx, 12
   278 00000B99 AB                  <2> 	stosd				; Offset 08h: PxFB – Port x FIS Base Address
   279 00000B9A 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
   280 00000B9E AB                  <2> 	stosd				; Offset 0Ch: PxFBU – Port x FIS Base Address Upper 32-bits
   281                              <2> 
   282 00000B9F 31C0                <2> 	xor eax, eax
   283 00000BA1 AB                  <2> 	stosd				; Offset 10h: PxIS – Port x Interrupt Status
   284 00000BA2 AB                  <2> 	stosd				; Offset 14h: PxIE – Port x Interrupt Enable
   285                              <2> 
   286                              <2> ahci_init_config_active_skip:
   287 00000BA3 48FFC1              <2> 	inc rcx
   288 00000BA6 EB99                <2> 	jmp ahci_init_config_active
   289                              <2> 
   290                              <2> ahci_init_config_active_done:
   291                              <2> 
   292                              <2> ahci_init_not_found:
   293 00000BA8 C3                  <2> 	ret
   294                              <2> ; -----------------------------------------------------------------------------
   295                              <2> 
   296                              <2> 
   297                              <2> ; -----------------------------------------------------------------------------
   298                              <2> ; ahci_read -- Read data from a SATA hard drive
   299                              <2> ; IN:	RAX = starting sector # to read (48-bit LBA address)
   300                              <2> ;	RCX = number of sectors to read (up to 8192 = 4MiB)
   301                              <2> ;	RDX = disk #
   302                              <2> ;	RDI = memory location to store sectors
   303                              <2> ; OUT:	RAX = RAX + number of sectors that were read
   304                              <2> ;	RCX = number of sectors that were read (0 on error)
   305                              <2> ;	RDI = RDI + (number of sectors read * 512)
   306                              <2> ;	All other registers preserved
   307                              <2> ahci_read:
   308 00000BA9 52                  <2> 	push rdx
   309 00000BAA 53                  <2> 	push rbx
   310 00000BAB 57                  <2> 	push rdi
   311 00000BAC 56                  <2> 	push rsi
   312 00000BAD 51                  <2> 	push rcx
   313 00000BAE 50                  <2> 	push rax
   314                              <2> 
   315 00000BAF 0FA314250C011100    <2> 	bt dword [ahci_PA], edx		; Is the requested disk marked as active?
   316 00000BB7 0F83C8000000        <2> 	jnc achi_read_error		; If not, bail out
   317                              <2> 
   318 00000BBD 51                  <2> 	push rcx			; Save the sector count
   319 00000BBE 57                  <2> 	push rdi			; Save the destination memory address
   320 00000BBF 50                  <2> 	push rax			; Save the block number
   321 00000BC0 50                  <2> 	push rax
   322                              <2> 
   323 00000BC1 488B342560001100    <2> 	mov rsi, [ahci_base]
   324 00000BC9 52                  <2> 	push rdx
   325 00000BCA 48C1E207            <2> 	shl rdx, 7			; Quick multiply by 0x80
   326 00000BCE 4881C200010000      <2> 	add rdx, 0x100			; Offset to port 0
   327 00000BD5 4801D6              <2> 	add rsi, rdx
   328 00000BD8 5A                  <2> 	pop rdx
   329                              <2> 
   330                              <2> 	; Build the Command List Header
   331 00000BD9 BF00001400          <2> 	mov rdi, ahci_CLB		; Command List (1K with 32 entries, 32 bytes each)
   332 00000BDE 48C1E20A            <2> 	shl rdx, 10
   333 00000BE2 4801D7              <2> 	add rdi, rdx
   334 00000BE5 48C1EA0A            <2> 	shr rdx, 10
   335 00000BE9 B805000100          <2> 	mov eax, 0x00010005		; 1 PRDTL Entry, Command FIS Length = 20 bytes
   336 00000BEE AB                  <2> 	stosd				; DW 0 - Description Information
   337 00000BEF 31C0                <2> 	xor eax, eax
   338 00000BF1 AB                  <2> 	stosd				; DW 1 - Command Status
   339 00000BF2 B800801600          <2> 	mov eax, ahci_CMD
   340 00000BF7 AB                  <2> 	stosd				; DW 2 - Command Table Base Address
   341 00000BF8 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
   342 00000BFC AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
   343 00000BFD 31C0                <2> 	xor eax, eax
   344 00000BFF 48AB                <2> 	stosq				; DW 4 - 7 are reserved
   345 00000C01 48AB                <2> 	stosq
   346                              <2> 
   347                              <2> 	; Build the Command Table
   348 00000C03 BF00801600          <2> 	mov rdi, ahci_CMD		; Build a command table for Port 0
   349 00000C08 B827802500          <2> 	mov eax, 0x00258027		; 25 READ DMA EXT, bit 15 set, FIS 27 H2D
   350 00000C0D AB                  <2> 	stosd				; feature 7:0, command, c, FIS
   351 00000C0E 58                  <2> 	pop rax				; Restore the start sector number
   352 00000C0F 48C1E024            <2> 	shl rax, 36
   353 00000C13 48C1E824            <2> 	shr rax, 36			; Upper 36 bits cleared
   354 00000C17 480FBAE81E          <2> 	bts rax, 30			; bit 30 set for LBA
   355 00000C1C AB                  <2> 	stosd				; device, LBA 23:16, LBA 15:8, LBA 7:0
   356 00000C1D 58                  <2> 	pop rax				; Restore the start sector number
   357 00000C1E 48C1E818            <2> 	shr rax, 24
   358 00000C22 AB                  <2> 	stosd				; feature 15:8, LBA 47:40, LBA 39:32, LBA 31:24
   359 00000C23 4889C8              <2> 	mov rax, rcx			; Read the number of sectors given in rcx
   360 00000C26 AB                  <2> 	stosd				; control, ICC, count 15:8, count 7:0
   361 00000C27 31C0                <2> 	xor eax, eax
   362 00000C29 AB                  <2> 	stosd				; reserved
   363                              <2> 
   364                              <2> 	; PRDT setup
   365 00000C2A BF80801600          <2> 	mov rdi, ahci_CMD + 0x80
   366 00000C2F 58                  <2> 	pop rax				; Restore the destination memory address
   367 00000C30 AB                  <2> 	stosd				; Data Base Address
   368 00000C31 48C1E820            <2> 	shr rax, 32
   369 00000C35 AB                  <2> 	stosd				; Data Base Address Upper
   370 00000C36 31C0                <2> 	xor eax, eax
   371 00000C38 AB                  <2> 	stosd				; Reserved
   372 00000C39 58                  <2> 	pop rax				; Restore the sector count
   373 00000C3A 48C1E009            <2> 	shl rax, 9			; multiply by 512 for bytes
   374 00000C3E 48FFC8              <2> 	dec rax				; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
   375 00000C41 AB                  <2> 	stosd				; Description Information (DBC is 21:00)
   376                              <2> 
   377 00000C42 31C0                <2> 	xor eax, eax
   378 00000C44 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
   379                              <2> 
   380 00000C47 B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
   381 00000C4C 894638              <2> 	mov [rsi+AHCI_PxCI], eax
   382                              <2> 
   383 00000C4F 31C0                <2> 	xor eax, eax
   384 00000C51 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
   385 00000C55 0FBAE800            <2> 	bts eax, 0			; Start (ST)
   386 00000C59 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
   387                              <2> 
   388                              <2> ahci_read_poll:
   389 00000C5C 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]
   390 00000C5F 85C0                <2> 	test eax, eax
   391 00000C61 75F9                <2> 	jnz ahci_read_poll
   392                              <2> 
   393 00000C63 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
   394 00000C66 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
   395 00000C6A 0FBAF000            <2> 	btr eax, 0			; Start (ST)
   396 00000C6E 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
   397                              <2> 
   398 00000C71 58                  <2> 	pop rax				; rax = start
   399 00000C72 59                  <2> 	pop rcx				; rcx = number of sectors read
   400 00000C73 4801C8              <2> 	add rax, rcx			; rax = start + number of sectors read
   401 00000C76 5E                  <2> 	pop rsi
   402 00000C77 5F                  <2> 	pop rdi
   403 00000C78 4889CB              <2> 	mov rbx, rcx			; rdi = dest addr + number of bytes read
   404 00000C7B 48C1E309            <2> 	shl rbx, 9
   405 00000C7F 4801DF              <2> 	add rdi, rbx
   406 00000C82 5B                  <2> 	pop rbx
   407 00000C83 5A                  <2> 	pop rdx
   408 00000C84 C3                  <2> 	ret
   409                              <2> 
   410                              <2> achi_read_error:
   411 00000C85 58                  <2> 	pop rax				; rax = start
   412 00000C86 59                  <2> 	pop rcx				; rcx = number of sectors read
   413 00000C87 5E                  <2> 	pop rsi
   414 00000C88 5F                  <2> 	pop rdi
   415 00000C89 5B                  <2> 	pop rbx
   416 00000C8A 5A                  <2> 	pop rdx
   417 00000C8B 31C9                <2> 	xor ecx, ecx
   418 00000C8D C3                  <2> 	ret
   419                              <2> ; -----------------------------------------------------------------------------
   420                              <2> 
   421                              <2> 
   422                              <2> ; -----------------------------------------------------------------------------
   423                              <2> ; ahci_write -- Write data to a SATA hard drive
   424                              <2> ; IN:	RAX = starting sector # to write (48-bit LBA Address)
   425                              <2> ;	RCX = number of sectors to write (up to 8192 = 4MiB)
   426                              <2> ;	RDX = disk #
   427                              <2> ;	RSI = memory location of sectors
   428                              <2> ; OUT:	RAX = RAX + number of sectors that were written
   429                              <2> ;	RCX = number of sectors that were written (0 on error)
   430                              <2> ;	RSI = RSI + (number of sectors written * 512)
   431                              <2> ;	All other registers preserved
   432                              <2> ahci_write:
   433 00000C8E 52                  <2> 	push rdx
   434 00000C8F 53                  <2> 	push rbx
   435 00000C90 57                  <2> 	push rdi
   436 00000C91 56                  <2> 	push rsi
   437 00000C92 51                  <2> 	push rcx
   438 00000C93 50                  <2> 	push rax
   439                              <2> 
   440 00000C94 0FA314250C011100    <2> 	bt dword [ahci_PA], edx		; Is the requested disk marked as active?
   441 00000C9C 0F83C8000000        <2> 	jnc achi_write_error		; If not, bail out
   442                              <2> 
   443 00000CA2 51                  <2> 	push rcx			; Save the sector count
   444 00000CA3 56                  <2> 	push rsi			; Save the source memory address
   445 00000CA4 50                  <2> 	push rax			; Save the block number
   446 00000CA5 50                  <2> 	push rax
   447                              <2> 
   448 00000CA6 488B342560001100    <2> 	mov rsi, [ahci_base]
   449 00000CAE 52                  <2> 	push rdx
   450 00000CAF 48C1E207            <2> 	shl rdx, 7			; Quick multiply by 0x80
   451 00000CB3 4881C200010000      <2> 	add rdx, 0x100			; Offset to port 0
   452 00000CBA 4801D6              <2> 	add rsi, rdx
   453 00000CBD 5A                  <2> 	pop rdx
   454                              <2> 
   455                              <2> 	; Build the Command List Header
   456 00000CBE BF00001400          <2> 	mov rdi, ahci_CLB		; Command List (1K with 32 entries, 32 bytes each)
   457 00000CC3 48C1E20A            <2> 	shl rdx, 10
   458 00000CC7 4801D7              <2> 	add rdi, rdx
   459 00000CCA 48C1EA0A            <2> 	shr rdx, 10
   460 00000CCE B845000100          <2> 	mov eax, 0x00010045		; 1 PRDTL Entry, write flag (bit 6), Command FIS Length = 20 bytes
   461 00000CD3 AB                  <2> 	stosd				; DW 0 - Description Information
   462 00000CD4 31C0                <2> 	xor eax, eax
   463 00000CD6 AB                  <2> 	stosd				; DW 1 - Command Status
   464 00000CD7 B800801600          <2> 	mov rax, ahci_CMD
   465 00000CDC AB                  <2> 	stosd				; DW 2 - Command Table Base Address
   466 00000CDD 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
   467 00000CE1 AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
   468 00000CE2 31C0                <2> 	xor eax, eax
   469 00000CE4 48AB                <2> 	stosq				; DW 4 - 7 are reserved
   470 00000CE6 48AB                <2> 	stosq
   471                              <2> 
   472                              <2> 	; Build the Command Table
   473 00000CE8 BF00801600          <2> 	mov rdi, ahci_CMD		; Build a command table for Port 0
   474 00000CED B827803500          <2> 	mov eax, 0x00358027		; 35 WRITE DMA EXT, bit 15 set, FIS 27 H2D
   475 00000CF2 AB                  <2> 	stosd				; feature 7:0, command, c, FIS
   476 00000CF3 58                  <2> 	pop rax				; Restore the start sector number
   477 00000CF4 48C1E024            <2> 	shl rax, 36
   478 00000CF8 48C1E824            <2> 	shr rax, 36			; Upper 36 bits cleared
   479 00000CFC 480FBAE81E          <2> 	bts rax, 30			; bit 30 set for LBA
   480 00000D01 AB                  <2> 	stosd				; device, LBA 23:16, LBA 15:8, LBA 7:0
   481 00000D02 58                  <2> 	pop rax				; Restore the start sector number
   482 00000D03 48C1E818            <2> 	shr rax, 24
   483 00000D07 AB                  <2> 	stosd				; feature 15:8, LBA 47:40, LBA 39:32, LBA 31:24
   484 00000D08 4889C8              <2> 	mov rax, rcx			; Read the number of sectors given in rcx
   485 00000D0B AB                  <2> 	stosd				; control, ICC, count 15:8, count 7:0
   486 00000D0C 31C0                <2> 	xor eax, eax
   487 00000D0E AB                  <2> 	stosd				; reserved
   488                              <2> 
   489                              <2> 	; PRDT setup
   490 00000D0F BF80801600          <2> 	mov rdi, ahci_CMD + 0x80
   491 00000D14 58                  <2> 	pop rax				; Restore the source memory address
   492 00000D15 AB                  <2> 	stosd				; Data Base Address
   493 00000D16 48C1E820            <2> 	shr rax, 32
   494 00000D1A AB                  <2> 	stosd				; Data Base Address Upper
   495 00000D1B 31C0                <2> 	xor eax, eax
   496 00000D1D AB                  <2> 	stosd				; Reserved
   497 00000D1E 58                  <2> 	pop rax				; Restore the sector count
   498 00000D1F 48C1E009            <2> 	shl rax, 9			; multiply by 512 for bytes
   499 00000D23 48FFC8              <2> 	dec rax				; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
   500 00000D26 AB                  <2> 	stosd				; Description Information (DBC is 21:00)
   501                              <2> 
   502 00000D27 31C0                <2> 	xor eax, eax
   503 00000D29 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
   504                              <2> 
   505 00000D2C B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
   506 00000D31 894638              <2> 	mov [rsi+AHCI_PxCI], eax
   507                              <2> 
   508 00000D34 31C0                <2> 	xor eax, eax
   509 00000D36 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
   510 00000D3A 0FBAE800            <2> 	bts eax, 0			; Start (ST)
   511 00000D3E 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
   512                              <2> 
   513                              <2> ahci_write_poll:
   514 00000D41 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]
   515 00000D44 85C0                <2> 	test eax, eax
   516 00000D46 75F9                <2> 	jnz ahci_write_poll
   517                              <2> 
   518 00000D48 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
   519 00000D4B 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
   520 00000D4F 0FBAF000            <2> 	btr eax, 0			; Start (ST)
   521 00000D53 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
   522                              <2> 
   523 00000D56 58                  <2> 	pop rax				; rax = start
   524 00000D57 59                  <2> 	pop rcx				; rcx = number of sectors read
   525 00000D58 4801C8              <2> 	add rax, rcx			; rax = start + number of sectors written
   526 00000D5B 5E                  <2> 	pop rsi
   527 00000D5C 5F                  <2> 	pop rdi
   528 00000D5D 4889CB              <2> 	mov rbx, rcx			; rdi = dest addr + number of bytes written
   529 00000D60 48C1E309            <2> 	shl rbx, 9
   530 00000D64 4801DF              <2> 	add rdi, rbx
   531 00000D67 5B                  <2> 	pop rbx
   532 00000D68 5A                  <2> 	pop rdx
   533 00000D69 C3                  <2> 	ret
   534                              <2> 
   535                              <2> achi_write_error:
   536 00000D6A 58                  <2> 	pop rax
   537 00000D6B 59                  <2> 	pop rcx
   538 00000D6C 5E                  <2> 	pop rsi
   539 00000D6D 5F                  <2> 	pop rdi
   540 00000D6E 5B                  <2> 	pop rbx
   541 00000D6F 5A                  <2> 	pop rdx
   542 00000D70 31C9                <2> 	xor ecx, ecx
   543 00000D72 C3                  <2> 	ret
   544                              <2> ; -----------------------------------------------------------------------------
   545                              <2> 
   546                              <2> 
   547                              <2> ; -----------------------------------------------------------------------------
   548                              <2> ; ahci_id -- Identify a SATA drive
   549                              <2> ; IN:	RDX = Port # to query
   550                              <2> ;	RDI = memory location to store details (512 bytes)
   551                              <2> ; OUT:	Nothing, all registers preserved
   552                              <2> ahci_id:
   553 00000D73 57                  <2> 	push rdi
   554 00000D74 56                  <2> 	push rsi
   555 00000D75 52                  <2> 	push rdx
   556 00000D76 50                  <2> 	push rax
   557 00000D77 57                  <2> 	push rdi			; Save the destination memory address
   558                              <2> 
   559 00000D78 0FA314250C011100    <2> 	bt dword [ahci_PA], edx		; Is the requested disk marked as active?
   560 00000D80 0F839C000000        <2> 	jnc ahci_id_error		; If not, bail out
   561                              <2> 
   562 00000D86 488B342560001100    <2> 	mov rsi, [ahci_base]
   563 00000D8E 52                  <2> 	push rdx
   564 00000D8F 48C1E207            <2> 	shl rdx, 7			; Quick multiply by 0x80
   565 00000D93 4881C200010000      <2> 	add rdx, 0x100			; Offset to port 0
   566 00000D9A 4801D6              <2> 	add rsi, rdx
   567 00000D9D 5A                  <2> 	pop rdx
   568                              <2> 
   569                              <2> 	; Build the Command List Header
   570 00000D9E BF00001400          <2> 	mov rdi, ahci_CLB		; Command List (1K with 32 entries, 32 bytes each)
   571 00000DA3 48C1E20A            <2> 	shl rdx, 10
   572 00000DA7 4801D7              <2> 	add rdi, rdx
   573 00000DAA 48C1EA0A            <2> 	shr rdx, 10
   574 00000DAE B805000100          <2> 	mov eax, 0x00010005		; 1 PRDTL Entry, Command FIS Length = 20 bytes
   575 00000DB3 AB                  <2> 	stosd				; DW 0 - Description Information
   576 00000DB4 31C0                <2> 	xor eax, eax
   577 00000DB6 AB                  <2> 	stosd				; DW 1 - Command Status
   578 00000DB7 B800801600          <2> 	mov rax, ahci_CMD
   579 00000DBC AB                  <2> 	stosd				; DW 2 - Command Table Base Address
   580 00000DBD 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
   581 00000DC1 AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
   582 00000DC2 31C0                <2> 	xor eax, eax
   583 00000DC4 48AB                <2> 	stosq				; DW 4 - 7 are reserved
   584 00000DC6 48AB                <2> 	stosq
   585                              <2> 
   586                              <2> 	; Build the Command Table
   587 00000DC8 BF00801600          <2> 	mov rdi, ahci_CMD		; Build a command table for Port 0
   588 00000DCD B82780EC00          <2> 	mov eax, 0x00EC8027		; EC identify, bit 15 set, FIS 27 H2D
   589 00000DD2 AB                  <2> 	stosd				; feature 7:0, command, c, FIS
   590 00000DD3 31C0                <2> 	xor eax, eax
   591 00000DD5 48AB                <2> 	stosq				; the rest of the table can be clear
   592 00000DD7 48AB                <2> 	stosq
   593                              <2> 
   594                              <2> 	; PRDT - pysical region descriptor table
   595 00000DD9 BF80801600          <2> 	mov rdi, ahci_CMD + 0x80
   596 00000DDE 58                  <2> 	pop rax				; Restore the destination memory address
   597 00000DDF AB                  <2> 	stosd				; Data Base Address
   598 00000DE0 48C1E820            <2> 	shr rax, 32
   599 00000DE4 AB                  <2> 	stosd				; Data Base Address Upper
   600 00000DE5 31C0                <2> 	xor eax, eax
   601 00000DE7 AB                  <2> 	stosd				; Reserved
   602 00000DE8 B8FF010000          <2> 	mov eax, 0x000001FF		; 512 - 1
   603 00000DED AB                  <2> 	stosd				; Description Information
   604                              <2> 
   605 00000DEE 31C0                <2> 	xor eax, eax
   606 00000DF0 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
   607                              <2> 
   608 00000DF3 B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
   609 00000DF8 894638              <2> 	mov [rsi+AHCI_PxCI], eax
   610                              <2> 
   611 00000DFB 31C0                <2> 	xor eax, eax
   612 00000DFD 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
   613 00000E01 0FBAE800            <2> 	bts eax, 0			; Start (ST)
   614 00000E05 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
   615                              <2> 
   616                              <2> ahci_id_poll:
   617 00000E08 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]	; Read Command Slot 0 status
   618 00000E0B 85C0                <2> 	test eax, eax
   619 00000E0D 75F9                <2> 	jnz ahci_id_poll
   620                              <2> 
   621 00000E0F 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
   622 00000E12 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
   623 00000E16 0FBAF000            <2> 	btr eax, 0			; Start (ST)
   624 00000E1A 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
   625                              <2> 
   626 00000E1D 58                  <2> 	pop rax
   627 00000E1E 5A                  <2> 	pop rdx
   628 00000E1F 5E                  <2> 	pop rsi
   629 00000E20 5F                  <2> 	pop rdi
   630 00000E21 C3                  <2> 	ret
   631                              <2> 
   632                              <2> ahci_id_error:
   633 00000E22 5F                  <2> 	pop rdi
   634 00000E23 58                  <2> 	pop rax
   635 00000E24 5A                  <2> 	pop rdx
   636 00000E25 5E                  <2> 	pop rsi
   637 00000E26 5F                  <2> 	pop rdi
   638 00000E27 B8FFFFFFFF          <2> 	mov eax, 0xFFFFFFFF
   639 00000E2C C3                  <2> 	ret
   640                              <2> ; -----------------------------------------------------------------------------
   641                              <2> 
   642                              <2> 
   643                              <2> ; HBA Memory Registers
   644                              <2> ; 0x0000 - 0x002B	Generic Host Control
   645                              <2> ; 0x002C - 0x005F	Reserved
   646                              <2> ; 0x0060 - 0x009F	Reserved for NVMHCI
   647                              <2> ; 0x00A0 - 0x00FF	Vendor Specific Registers
   648                              <2> ; 0x0100 - 0x017F	Port 0
   649                              <2> ; 0x0180 - 0x01FF	Port 1
   650                              <2> ; ...
   651                              <2> ; 0x1000 - 0x107F	Port 30
   652                              <2> ; 0x1080 - 0x10FF	Port 31
   653                              <2> 
   654                              <2> ; Generic Host Control
   655                              <2> AHCI_CAP		equ 0x0000 ; HBA Capabilities
   656                              <2> AHCI_GHC		equ 0x0004 ; Global HBA Control
   657                              <2> AHCI_IS			equ 0x0008 ; Interrupt Status Register
   658                              <2> AHCI_PI			equ 0x000C ; Ports Implemented
   659                              <2> AHCI_VS			equ 0x0010 ; AHCI Version
   660                              <2> AHCI_CCC_CTL		equ 0x0014 ; Command Completion Coalescing Control
   661                              <2> AHCI_CCC_PORTS		equ 0x0018 ; Command Completion Coalescing Ports
   662                              <2> AHCI_EM_LOC		equ 0x001C ; Enclosure Management Location
   663                              <2> AHCI_EM_CTL		equ 0x0020 ; Enclosure Management Control
   664                              <2> AHCI_CAP2		equ 0x0024 ; HBA Capabilities Extended
   665                              <2> AHCI_BOHC		equ 0x0028 ; BIOS/OS Handoff Control and Status
   666                              <2> 
   667                              <2> ; Port Registers
   668                              <2> ; Port 0 starts at 100h, port 1 starts at 180h, port 2 starts at 200h, port 3 at 280h, etc.
   669                              <2> AHCI_PxCLB		equ 0x0000 ; Port x Command List Base Address
   670                              <2> AHCI_PxCLBU		equ 0x0004 ; Port x Command List Base Address Upper 32-bits
   671                              <2> AHCI_PxFB		equ 0x0008 ; Port x FIS Base Address
   672                              <2> AHCI_PxFBU		equ 0x000C ; Port x FIS Base Address Upper 32-bits
   673                              <2> AHCI_PxIS		equ 0x0010 ; Port x Interrupt Status
   674                              <2> AHCI_PxIE		equ 0x0014 ; Port x Interrupt Enable
   675                              <2> AHCI_PxCMD		equ 0x0018 ; Port x Command and Status
   676                              <2> AHCI_PxTFD		equ 0x0020 ; Port x Task File Data
   677                              <2> AHCI_PxSIG		equ 0x0024 ; Port x Signature
   678                              <2> AHCI_PxSSTS		equ 0x0028 ; Port x Serial ATA Status (SCR0: SStatus)
   679                              <2> AHCI_PxSCTL		equ 0x002C ; Port x Serial ATA Control (SCR2: SControl)
   680                              <2> AHCI_PxSERR		equ 0x0030 ; Port x Serial ATA Error (SCR1: SError)
   681                              <2> AHCI_PxSACT		equ 0x0034 ; Port x Serial ATA Active (SCR3: SActive)
   682                              <2> AHCI_PxCI		equ 0x0038 ; Port x Command Issue
   683                              <2> AHCI_PxSNTF		equ 0x003C ; Port x Serial ATA Notification (SCR4: SNotification)
   684                              <2> AHCI_PxFBS		equ 0x0040 ; Port x FIS-based Switching Control
   685                              <2> AHCI_PxDEVSLP		equ 0x0044 ; Port x Device Sleep
   686                              <2> ; 0x0048 - 0x006F	Reserved
   687                              <2> ; 0x0070 - 0x007F	Port x Vendor Specific
   688                              <2> 
   689                              <2> 
   690                              <2> ; =============================================================================
   691                              <2> ; EOF
   182                              <1> 
   183                              <1> ; Network
   184                              <1> %include "drivers/net/i8254x.asm"
   185                              <2> ; =============================================================================
   186                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   187                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   188                              <2> ;
   189                              <2> ; Intel i8254x Driver
   190                              <2> ; =============================================================================
   191                              <2> 
   192                              <2> 
   193                              <2> ; -----------------------------------------------------------------------------
   194                              <2> ; Initialize an Intel 8254x NIC
   195                              <2> ;  IN:	EDX = Packed PCI address (as per pci.asm)
   196                              <2> net_i8254x_init:
   197 00000E2D 56                  <2> 	push rsi
   198 00000E2E 52                  <2> 	push rdx
   199 00000E2F 51                  <2> 	push rcx
   200 00000E30 50                  <2> 	push rax
   201                              <2> 
   202                              <2> 	; Read BAR4, If BAR4 is all 0'z then we are using 32-bit addresses
   203                              <2> 
   204                              <2> 	; Grab the Base I/O Address of the device
   205 00000E31 B204                <2> 	mov dl, 0x04				; BAR0
   206 00000E33 E827FCFFFF          <2> 	call os_pci_read
   207 00000E38 83E0F0              <2> 	and eax, 0xFFFFFFF0			; EAX now holds the Base Memory IO Address (clear the low 4 bits)
   208 00000E3B 89042548001100      <2> 	mov dword [os_NetIOBaseMem], eax
   209                              <2> 
   210                              <2> 	; Grab the IRQ of the device
   211 00000E42 B20F                <2> 	mov dl, 0x0F				; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
   212 00000E44 E816FCFFFF          <2> 	call os_pci_read
   213 00000E49 8804250A031100      <2> 	mov [os_NetIRQ], al			; AL holds the IRQ
   214                              <2> 
   215                              <2> 	; Enable PCI Bus Mastering
   216 00000E50 B201                <2> 	mov dl, 0x01				; Get Status/Command
   217 00000E52 E808FCFFFF          <2> 	call os_pci_read
   218 00000E57 0FBAE802            <2> 	bts eax, 2
   219 00000E5B E81DFCFFFF          <2> 	call os_pci_write
   220                              <2> 
   221                              <2> 	; Grab the MAC address
   222 00000E60 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
   223 00000E68 8B8600540000        <2> 	mov eax, [rsi+0x5400]			; RAL
   224 00000E6E 83F800              <2> 	cmp eax, 0x00000000
   225 00000E71 743E                <2> 	je net_i8254x_init_get_MAC_via_EPROM
   226 00000E73 88042550001100      <2> 	mov [os_NetMAC], al
   227 00000E7A C1E808              <2> 	shr eax, 8
   228 00000E7D 88042551001100      <2> 	mov [os_NetMAC+1], al
   229 00000E84 C1E808              <2> 	shr eax, 8
   230 00000E87 88042552001100      <2> 	mov [os_NetMAC+2], al
   231 00000E8E C1E808              <2> 	shr eax, 8
   232 00000E91 88042553001100      <2> 	mov [os_NetMAC+3], al
   233 00000E98 8B8604540000        <2> 	mov eax, [rsi+0x5404]			; RAH
   234 00000E9E 88042554001100      <2> 	mov [os_NetMAC+4], al
   235 00000EA5 C1E808              <2> 	shr eax, 8
   236 00000EA8 88042555001100      <2> 	mov [os_NetMAC+5], al
   237 00000EAF EB65                <2> 	jmp net_i8254x_init_done_MAC
   238                              <2> 
   239                              <2> net_i8254x_init_get_MAC_via_EPROM:
   240 00000EB1 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
   241 00000EB9 B801000000          <2> 	mov eax, 0x00000001
   242 00000EBE 894614              <2> 	mov [rsi+0x14], eax
   243 00000EC1 8B4614              <2> 	mov eax, [rsi+0x14]
   244 00000EC4 C1E810              <2> 	shr eax, 16
   245 00000EC7 88042550001100      <2> 	mov [os_NetMAC], al
   246 00000ECE C1E808              <2> 	shr eax, 8
   247 00000ED1 88042551001100      <2> 	mov [os_NetMAC+1], al
   248 00000ED8 B801010000          <2> 	mov eax, 0x00000101
   249 00000EDD 894614              <2> 	mov [rsi+0x14], eax
   250 00000EE0 8B4614              <2> 	mov eax, [rsi+0x14]
   251 00000EE3 C1E810              <2> 	shr eax, 16
   252 00000EE6 88042552001100      <2> 	mov [os_NetMAC+2], al
   253 00000EED C1E808              <2> 	shr eax, 8
   254 00000EF0 88042553001100      <2> 	mov [os_NetMAC+3], al
   255 00000EF7 B801020000          <2> 	mov eax, 0x00000201
   256 00000EFC 894614              <2> 	mov [rsi+0x14], eax
   257 00000EFF 8B4614              <2> 	mov eax, [rsi+0x14]
   258 00000F02 C1E810              <2> 	shr eax, 16
   259 00000F05 88042554001100      <2> 	mov [os_NetMAC+4], al
   260 00000F0C C1E808              <2> 	shr eax, 8
   261 00000F0F 88042555001100      <2> 	mov [os_NetMAC+5], al
   262                              <2> net_i8254x_init_done_MAC:
   263                              <2> 
   264                              <2> 	; Reset the device
   265 00000F16 E805000000          <2> 	call net_i8254x_reset
   266                              <2> 
   267 00000F1B 58                  <2> 	pop rax
   268 00000F1C 59                  <2> 	pop rcx
   269 00000F1D 5A                  <2> 	pop rdx
   270 00000F1E 5E                  <2> 	pop rsi
   271 00000F1F C3                  <2> 	ret
   272                              <2> ; -----------------------------------------------------------------------------
   273                              <2> 
   274                              <2> 
   275                              <2> ; -----------------------------------------------------------------------------
   276                              <2> ; net_i8254x_reset - Reset an Intel 8254x NIC
   277                              <2> ;  IN:	Nothing
   278                              <2> ; OUT:	Nothing, all registers preserved
   279                              <2> net_i8254x_reset:
   280 00000F20 57                  <2> 	push rdi
   281 00000F21 56                  <2> 	push rsi
   282 00000F22 50                  <2> 	push rax
   283                              <2> 
   284 00000F23 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
   285 00000F2B 4889F7              <2> 	mov rdi, rsi
   286                              <2> 
   287 00000F2E B8FFFFFFFF          <2> 	mov eax, 0xFFFFFFFF
   288 00000F33 8986D8000000        <2> 	mov [rsi+I8254X_REG_IMC], eax		; Disable all interrupt causes
   289 00000F39 8B86C0000000        <2> 	mov eax, [rsi+I8254X_REG_ICR]		; Clear any pending interrupts
   290 00000F3F 31C0                <2> 	xor eax, eax
   291 00000F41 8986C4000000        <2> 	mov [rsi+I8254X_REG_ITR], eax		; Disable interrupt throttling logic
   292                              <2> 
   293 00000F47 B830000000          <2> 	mov eax, 0x00000030
   294 00000F4C 898600100000        <2> 	mov [rsi+I8254X_REG_PBA], eax		; PBA: set the RX buffer size to 48KB (TX buffer is calculated as 64-RX buffer)
   295                              <2> 
   296 00000F52 B860800080          <2> 	mov eax, 0x80008060
   297 00000F57 898678010000        <2> 	mov [rsi+I8254X_REG_TXCW], eax		; TXCW: set ANE, TxConfigWord (Half/Full duplex, Next Page Request)
   298                              <2> 
   299 00000F5D 8B06                <2> 	mov eax, [rsi+I8254X_REG_CTRL]
   300 00000F5F 0FBAF003            <2> 	btr eax, 3				; LRST = 0
   301 00000F63 0FBAE806            <2> 	bts eax, 6				; SLU = 1
   302 00000F67 0FBAE805            <2> 	bts eax, 5				; ASDE = 1
   303 00000F6B 0FBAF01F            <2> 	btr eax, 31				; PHY_RST = 0
   304 00000F6F 0FBAF01E            <2> 	btr eax, 30				; VME = 0 (Disable 802.1Q)
   305 00000F73 0FBAF007            <2> 	btr eax, 7				; ILOS = 0
   306 00000F77 8906                <2> 	mov [rsi+I8254X_REG_CTRL], eax		; CTRL: clear LRST, set SLU and ASDE, clear RSTPHY, VME, and ILOS
   307                              <2> 
   308 00000F79 57                  <2> 	push rdi
   309 00000F7A 4881C700520000      <2> 	add rdi, I8254X_REG_MTA			; MTA: reset
   310 00000F81 B8FFFFFFFF          <2> 	mov eax, 0xFFFFFFFF
   311 00000F86 AB                  <2> 	stosd
   312 00000F87 AB                  <2> 	stosd
   313 00000F88 AB                  <2> 	stosd
   314 00000F89 AB                  <2> 	stosd
   315 00000F8A 5F                  <2> 	pop rdi
   316                              <2> 
   317 00000F8B B800001A00          <2> 	mov rax, os_rx_desc
   318 00000F90 898600280000        <2> 	mov [rsi+I8254X_REG_RDBAL], eax		; Receive Descriptor Base Address Low
   319 00000F96 48C1E820            <2> 	shr rax, 32
   320 00000F9A 898604280000        <2> 	mov [rsi+I8254X_REG_RDBAH], eax		; Receive Descriptor Base Address High
   321 00000FA0 B800010000          <2> 	mov eax, (32 * 8)			; Multiples of 8, each desciptor is 16 bytes
   322 00000FA5 898608280000        <2> 	mov [rsi+I8254X_REG_RDLEN], eax		; Receive Descriptor Length
   323 00000FAB 31C0                <2> 	xor eax, eax
   324 00000FAD 898610280000        <2> 	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head
   325 00000FB3 B801000000          <2> 	mov eax, 1
   326 00000FB8 898618280000        <2> 	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail
   327 00000FBE B826800004          <2> 	mov eax, 0x04008026			; Receiver Enable, Store Bad Packets, Long Packet Reception, Broadcast Accept Mode, Strip Ethernet CRC from incoming packet
   328 00000FC3 898600010000        <2> 	mov [rsi+I8254X_REG_RCTL], eax		; Receive Control Register
   329                              <2> 
   330 00000FC9 57                  <2> 	push rdi
   331 00000FCA BF00001A00          <2> 	mov rdi, os_rx_desc
   332 00000FCF B800001B00          <2> 	mov rax, os_PacketBuffers		; Default packet will go here
   333 00000FD4 4883C002            <2> 	add rax, 2				; Room for packet length
   334 00000FD8 AB                  <2> 	stosd
   335 00000FD9 5F                  <2> 	pop rdi
   336                              <2> 
   337 00000FDA B800801A00          <2> 	mov rax, os_tx_desc
   338 00000FDF 898600380000        <2> 	mov [rsi+I8254X_REG_TDBAL], eax		; Transmit Descriptor Base Address Low
   339 00000FE5 48C1E820            <2> 	shr rax, 32
   340 00000FE9 898604380000        <2> 	mov [rsi+I8254X_REG_TDBAH], eax		; Transmit Descriptor Base Address High
   341 00000FEF B800010000          <2> 	mov eax, (32 * 8)			; Multiples of 8, each desciptor is 16 bytes
   342 00000FF4 898608380000        <2> 	mov [rsi+I8254X_REG_TDLEN], eax		; Transmit Descriptor Length
   343 00000FFA 31C0                <2> 	xor eax, eax
   344 00000FFC 898610380000        <2> 	mov [rsi+I8254X_REG_TDH], eax		; Transmit Descriptor Head
   345 00001002 898618380000        <2> 	mov [rsi+I8254X_REG_TDT], eax		; Transmit Descriptor Tail
   346 00001008 B8FA000401          <2> 	mov eax, 0x010400FA			; Enabled, Pad Short Packets, 15 retries, 64-byte COLD, Re-transmit on Late Collision
   347 0000100D 898600040000        <2> 	mov [rsi+I8254X_REG_TCTL], eax		; Transmit Control Register
   348 00001013 B80A206000          <2> 	mov eax, 0x0060200A			; IPGT 10, IPGR1 8, IPGR2 6
   349 00001018 898610040000        <2> 	mov [rsi+I8254X_REG_TIPG], eax		; Transmit IPG Register
   350                              <2> 
   351 0000101E 31C0                <2> 	xor eax, eax
   352 00001020 898620280000        <2> 	mov [rsi+I8254X_REG_RDTR], eax		; Clear the Receive Delay Timer Register
   353 00001026 89862C280000        <2> 	mov [rsi+I8254X_REG_RADV], eax		; Clear the Receive Interrupt Absolute Delay Timer
   354 0000102C 8986002C0000        <2> 	mov [rsi+I8254X_REG_RSRPD], eax		; Clear the Receive Small Packet Detect Interrupt
   355                              <2> 
   356 00001032 B8FFFF0100          <2> 	mov eax, 0x1FFFF			; Temp enable all interrupt types
   357 00001037 8986D0000000        <2> 	mov [rsi+I8254X_REG_IMS], eax		; Enable interrupt types
   358                              <2> 
   359 0000103D 58                  <2> 	pop rax
   360 0000103E 5E                  <2> 	pop rsi
   361 0000103F 5F                  <2> 	pop rdi
   362 00001040 C3                  <2> 	ret
   363                              <2> ; -----------------------------------------------------------------------------
   364                              <2> 
   365                              <2> 
   366                              <2> ; -----------------------------------------------------------------------------
   367                              <2> ; net_i8254x_transmit - Transmit a packet via an Intel 8254x NIC
   368                              <2> ;  IN:	RSI = Location of packet
   369                              <2> ;	RCX = Length of packet
   370                              <2> ; OUT:	Nothing
   371                              <2> net_i8254x_transmit:
   372 00001041 57                  <2> 	push rdi
   373 00001042 50                  <2> 	push rax
   374                              <2> 
   375 00001043 BF00801A00          <2> 	mov rdi, os_tx_desc			; Transmit Descriptor Base Address
   376 00001048 4889F0              <2> 	mov rax, rsi
   377 0000104B 48AB                <2> 	stosq					; Store the data location
   378 0000104D 4889C8              <2> 	mov rax, rcx				; The packet size is in CX
   379 00001050 480FBAE818          <2> 	bts rax, 24				; EOP
   380 00001055 480FBAE819          <2> 	bts rax, 25				; IFCS
   381 0000105A 480FBAE81B          <2> 	bts rax, 27				; RS
   382 0000105F 48AB                <2> 	stosq
   383 00001061 488B3C2548001100    <2> 	mov rdi, [os_NetIOBaseMem]
   384 00001069 31C0                <2> 	xor eax, eax
   385 0000106B 898710380000        <2> 	mov [rdi+I8254X_REG_TDH], eax		; TDH - Transmit Descriptor Head
   386 00001071 FFC0                <2> 	inc eax
   387 00001073 898718380000        <2> 	mov [rdi+I8254X_REG_TDT], eax		; TDL - Transmit Descriptor Tail
   388                              <2> 
   389 00001079 58                  <2> 	pop rax
   390 0000107A 5F                  <2> 	pop rdi
   391 0000107B C3                  <2> 	ret
   392                              <2> ; -----------------------------------------------------------------------------
   393                              <2> 
   394                              <2> 
   395                              <2> ; -----------------------------------------------------------------------------
   396                              <2> ; net_i8254x_poll - Polls the Intel 8254x NIC for a received packet
   397                              <2> ;  IN:	RDI = Location to store packet
   398                              <2> ; OUT:	RCX = Length of packet
   399                              <2> net_i8254x_poll:
   400 0000107C 57                  <2> 	push rdi
   401 0000107D 56                  <2> 	push rsi
   402 0000107E 50                  <2> 	push rax
   403                              <2> 
   404 0000107F 31C9                <2> 	xor ecx, ecx
   405 00001081 668B0C2508001A00    <2> 	mov cx, [os_rx_desc+8]			; Get the packet length
   406 00001089 BF00001B00          <2> 	mov rdi, os_PacketBuffers
   407 0000108E 66890F              <2> 	mov [rdi], word cx
   408                              <2> 
   409 00001091 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
   410 00001099 31C0                <2> 	xor eax, eax
   411 0000109B 898610280000        <2> 	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head
   412 000010A1 FFC0                <2> 	inc eax
   413 000010A3 898618280000        <2> 	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail
   414                              <2> 
   415 000010A9 BF00001A00          <2> 	mov rdi, os_rx_desc
   416 000010AE B800001B00          <2> 	mov rax, os_PacketBuffers		; Packet will go here
   417 000010B3 4883C002            <2> 	add rax, 2				; Room for packet length
   418 000010B7 AB                  <2> 	stosd
   419                              <2> 
   420 000010B8 58                  <2> 	pop rax
   421 000010B9 5E                  <2> 	pop rsi
   422 000010BA 5F                  <2> 	pop rdi
   423 000010BB C3                  <2> 	ret
   424                              <2> ; -----------------------------------------------------------------------------
   425                              <2> 
   426                              <2> 
   427                              <2> ; -----------------------------------------------------------------------------
   428                              <2> ; net_i8254x_ack_int - Acknowledge an internal interrupt of the Intel 8254x NIC
   429                              <2> ;  IN:	Nothing
   430                              <2> ; OUT:	RAX = Ethernet status
   431                              <2> net_i8254x_ack_int:
   432 000010BC 57                  <2> 	push rdi
   433                              <2> 
   434 000010BD 31C0                <2> 	xor eax, eax
   435 000010BF 488B3C2548001100    <2> 	mov rdi, [os_NetIOBaseMem]
   436 000010C7 8B87C0000000        <2> 	mov eax, [rdi+I8254X_REG_ICR]
   437                              <2> 
   438 000010CD 5F                  <2> 	pop rdi
   439 000010CE C3                  <2> 	ret
   440                              <2> ; -----------------------------------------------------------------------------
   441                              <2> 
   442                              <2> 
   443                              <2> ; Maximum packet size
   444                              <2> I8254X_MAX_PKT_SIZE	equ 16384
   445                              <2> 
   446                              <2> ; Register list
   447                              <2> I8254X_REG_CTRL		equ 0x0000 ; Control Register
   448                              <2> I8254X_REG_STATUS	equ 0x0008 ; Device Status Register
   449                              <2> I8254X_REG_CTRLEXT	equ 0x0018 ; Extended Control Register
   450                              <2> I8254X_REG_MDIC		equ 0x0020 ; MDI Control Register
   451                              <2> I8254X_REG_FCAL		equ 0x0028 ; Flow Control Address Low
   452                              <2> I8254X_REG_FCAH		equ 0x002C ; Flow Control Address High
   453                              <2> I8254X_REG_FCT		equ 0x0030 ; Flow Control Type
   454                              <2> I8254X_REG_VET		equ 0x0038 ; VLAN Ether Type
   455                              <2> I8254X_REG_ICR		equ 0x00C0 ; Interrupt Cause Read
   456                              <2> I8254X_REG_ITR		equ 0x00C4 ; Interrupt Throttling Register
   457                              <2> I8254X_REG_ICS		equ 0x00C8 ; Interrupt Cause Set Register
   458                              <2> I8254X_REG_IMS		equ 0x00D0 ; Interrupt Mask Set/Read Register
   459                              <2> I8254X_REG_IMC		equ 0x00D8 ; Interrupt Mask Clear Register
   460                              <2> I8254X_REG_RCTL		equ 0x0100 ; Receive Control Register
   461                              <2> I8254X_REG_FCTTV	equ 0x0170 ; Flow Control Transmit Timer Value
   462                              <2> I8254X_REG_TXCW		equ 0x0178 ; Transmit Configuration Word
   463                              <2> I8254X_REG_RXCW		equ 0x0180 ; Receive Configuration Word
   464                              <2> I8254X_REG_TCTL		equ 0x0400 ; Transmit Control Register
   465                              <2> I8254X_REG_TIPG		equ 0x0410 ; Transmit Inter Packet Gap
   466                              <2> 
   467                              <2> I8254X_REG_LEDCTL	equ 0x0E00 ; LED Control
   468                              <2> I8254X_REG_PBA		equ 0x1000 ; Packet Buffer Allocation
   469                              <2> 
   470                              <2> I8254X_REG_RDBAL	equ 0x2800 ; RX Descriptor Base Address Low
   471                              <2> I8254X_REG_RDBAH	equ 0x2804 ; RX Descriptor Base Address High
   472                              <2> I8254X_REG_RDLEN	equ 0x2808 ; RX Descriptor Length
   473                              <2> I8254X_REG_RDH		equ 0x2810 ; RX Descriptor Head
   474                              <2> I8254X_REG_RDT		equ 0x2818 ; RX Descriptor Tail
   475                              <2> I8254X_REG_RDTR		equ 0x2820 ; RX Delay Timer Register
   476                              <2> I8254X_REG_RXDCTL	equ 0x3828 ; RX Descriptor Control
   477                              <2> I8254X_REG_RADV		equ 0x282C ; RX Int. Absolute Delay Timer
   478                              <2> I8254X_REG_RSRPD	equ 0x2C00 ; RX Small Packet Detect Interrupt
   479                              <2> 
   480                              <2> I8254X_REG_TXDMAC	equ 0x3000 ; TX DMA Control
   481                              <2> I8254X_REG_TDBAL	equ 0x3800 ; TX Descriptor Base Address Low
   482                              <2> I8254X_REG_TDBAH	equ 0x3804 ; TX Descriptor Base Address High
   483                              <2> I8254X_REG_TDLEN	equ 0x3808 ; TX Descriptor Length
   484                              <2> I8254X_REG_TDH		equ 0x3810 ; TX Descriptor Head
   485                              <2> I8254X_REG_TDT		equ 0x3818 ; TX Descriptor Tail
   486                              <2> I8254X_REG_TIDV		equ 0x3820 ; TX Interrupt Delay Value
   487                              <2> I8254X_REG_TXDCTL	equ 0x3828 ; TX Descriptor Control
   488                              <2> I8254X_REG_TADV		equ 0x382C ; TX Absolute Interrupt Delay Value
   489                              <2> I8254X_REG_TSPMT	equ 0x3830 ; TCP Segmentation Pad & Min Threshold
   490                              <2> 
   491                              <2> I8254X_REG_RXCSUM	equ 0x5000 ; RX Checksum Control
   492                              <2> I8254X_REG_MTA		equ 0x5200 ; Multicast Table Array
   493                              <2> 
   494                              <2> ; Register list for i8254x
   495                              <2> I82542_REG_RDTR		equ 0x0108 ; RX Delay Timer Register
   496                              <2> I82542_REG_RDBAL	equ 0x0110 ; RX Descriptor Base Address Low
   497                              <2> I82542_REG_RDBAH	equ 0x0114 ; RX Descriptor Base Address High
   498                              <2> I82542_REG_RDLEN	equ 0x0118 ; RX Descriptor Length
   499                              <2> I82542_REG_RDH		equ 0x0120 ; RDH for i82542
   500                              <2> I82542_REG_RDT		equ 0x0128 ; RDT for i82542
   501                              <2> I82542_REG_TDBAL	equ 0x0420 ; TX Descriptor Base Address Low
   502                              <2> I82542_REG_TDBAH	equ 0x0424 ; TX Descriptor Base Address Low
   503                              <2> I82542_REG_TDLEN	equ 0x0428 ; TX Descriptor Length
   504                              <2> I82542_REG_TDH		equ 0x0430 ; TDH for i82542
   505                              <2> I82542_REG_TDT		equ 0x0438 ; TDT for i82542
   506                              <2> 
   507                              <2> ; CTRL - Control Register (0x0000)
   508                              <2> I8254X_CTRL_FD		equ 0x00000001 ; Full Duplex
   509                              <2> I8254X_CTRL_LRST	equ 0x00000008 ; Link Reset
   510                              <2> I8254X_CTRL_ASDE	equ 0x00000020 ; Auto-speed detection
   511                              <2> I8254X_CTRL_SLU		equ 0x00000040 ; Set Link Up
   512                              <2> I8254X_CTRL_ILOS	equ 0x00000080 ; Invert Loss of Signal
   513                              <2> I8254X_CTRL_SPEED_MASK	equ 0x00000300 ; Speed selection
   514                              <2> I8254X_CTRL_SPEED_SHIFT	equ 8
   515                              <2> I8254X_CTRL_FRCSPD	equ 0x00000800 ; Force Speed
   516                              <2> I8254X_CTRL_FRCDPLX	equ 0x00001000 ; Force Duplex
   517                              <2> I8254X_CTRL_SDP0_DATA	equ 0x00040000 ; SDP0 data
   518                              <2> I8254X_CTRL_SDP1_DATA	equ 0x00080000 ; SDP1 data
   519                              <2> I8254X_CTRL_SDP0_IODIR	equ 0x00400000 ; SDP0 direction
   520                              <2> I8254X_CTRL_SDP1_IODIR	equ 0x00800000 ; SDP1 direction
   521                              <2> I8254X_CTRL_RST		equ 0x04000000 ; Device Reset
   522                              <2> I8254X_CTRL_RFCE	equ 0x08000000 ; RX Flow Ctrl Enable
   523                              <2> I8254X_CTRL_TFCE	equ 0x10000000 ; TX Flow Ctrl Enable
   524                              <2> I8254X_CTRL_VME		equ 0x40000000 ; VLAN Mode Enable
   525                              <2> I8254X_CTRL_PHY_RST	equ 0x80000000 ; PHY reset
   526                              <2> 
   527                              <2> ; STATUS - Device Status Register (0x0008)
   528                              <2> I8254X_STATUS_FD		equ 0x00000001 ; Full Duplex
   529                              <2> I8254X_STATUS_LU		equ 0x00000002 ; Link Up
   530                              <2> I8254X_STATUS_TXOFF		equ 0x00000010 ; Transmit paused
   531                              <2> I8254X_STATUS_TBIMODE		equ 0x00000020 ; TBI Mode
   532                              <2> I8254X_STATUS_SPEED_MASK	equ 0x000000C0 ; Link Speed setting
   533                              <2> I8254X_STATUS_SPEED_SHIFT	equ 6
   534                              <2> I8254X_STATUS_ASDV_MASK		equ 0x00000300 ; Auto Speed Detection
   535                              <2> I8254X_STATUS_ASDV_SHIFT	equ 8
   536                              <2> I8254X_STATUS_PCI66		equ 0x00000800 ; PCI bus speed
   537                              <2> I8254X_STATUS_BUS64		equ 0x00001000 ; PCI bus width
   538                              <2> I8254X_STATUS_PCIX_MODE		equ 0x00002000 ; PCI-X mode
   539                              <2> I8254X_STATUS_PCIXSPD_MASK	equ 0x0000C000 ; PCI-X speed
   540                              <2> I8254X_STATUS_PCIXSPD_SHIFT	equ 14
   541                              <2> 
   542                              <2> ; CTRL_EXT - Extended Device Control Register (0x0018)
   543                              <2> I8254X_CTRLEXT_PHY_INT		equ 0x00000020 ; PHY interrupt
   544                              <2> I8254X_CTRLEXT_SDP6_DATA	equ 0x00000040 ; SDP6 data
   545                              <2> I8254X_CTRLEXT_SDP7_DATA	equ 0x00000080 ; SDP7 data
   546                              <2> I8254X_CTRLEXT_SDP6_IODIR	equ 0x00000400 ; SDP6 direction
   547                              <2> I8254X_CTRLEXT_SDP7_IODIR	equ 0x00000800 ; SDP7 direction
   548                              <2> I8254X_CTRLEXT_ASDCHK		equ 0x00001000 ; Auto-Speed Detect Chk
   549                              <2> I8254X_CTRLEXT_EE_RST		equ 0x00002000 ; EEPROM reset
   550                              <2> I8254X_CTRLEXT_SPD_BYPS		equ 0x00008000 ; Speed Select Bypass
   551                              <2> I8254X_CTRLEXT_RO_DIS		equ 0x00020000 ; Relaxed Ordering Dis.
   552                              <2> I8254X_CTRLEXT_LNKMOD_MASK	equ 0x00C00000 ; Link Mode
   553                              <2> I8254X_CTRLEXT_LNKMOD_SHIFT	equ 22
   554                              <2> 
   555                              <2> ; MDIC - MDI Control Register (0x0020)
   556                              <2> I8254X_MDIC_DATA_MASK	equ 0x0000FFFF ; Data
   557                              <2> I8254X_MDIC_REG_MASK	equ 0x001F0000 ; PHY Register
   558                              <2> I8254X_MDIC_REG_SHIFT	equ 16
   559                              <2> I8254X_MDIC_PHY_MASK	equ 0x03E00000 ; PHY Address
   560                              <2> I8254X_MDIC_PHY_SHIFT	equ 21
   561                              <2> I8254X_MDIC_OP_MASK	equ 0x0C000000 ; Opcode
   562                              <2> I8254X_MDIC_OP_SHIFT	equ 26
   563                              <2> I8254X_MDIC_R		equ 0x10000000 ; Ready
   564                              <2> I8254X_MDIC_I		equ 0x20000000 ; Interrupt Enable
   565                              <2> I8254X_MDIC_E		equ 0x40000000 ; Error
   566                              <2> 
   567                              <2> ; ICR - Interrupt Cause Read (0x00c0)
   568                              <2> I8254X_ICR_TXDW		equ 0x00000001 ; TX Desc Written back
   569                              <2> I8254X_ICR_TXQE		equ 0x00000002 ; TX Queue Empty
   570                              <2> I8254X_ICR_LSC		equ 0x00000004 ; Link Status Change
   571                              <2> I8254X_ICR_RXSEQ	equ 0x00000008 ; RX Sequence Error
   572                              <2> I8254X_ICR_RXDMT0	equ 0x00000010 ; RX Desc min threshold reached
   573                              <2> I8254X_ICR_RXO		equ 0x00000040 ; RX Overrun
   574                              <2> I8254X_ICR_RXT0		equ 0x00000080 ; RX Timer Interrupt
   575                              <2> I8254X_ICR_MDAC		equ 0x00000200 ; MDIO Access Complete
   576                              <2> I8254X_ICR_RXCFG	equ 0x00000400
   577                              <2> I8254X_ICR_PHY_INT	equ 0x00001000 ; PHY Interrupt
   578                              <2> I8254X_ICR_GPI_SDP6	equ 0x00002000 ; GPI on SDP6
   579                              <2> I8254X_ICR_GPI_SDP7	equ 0x00004000 ; GPI on SDP7
   580                              <2> I8254X_ICR_TXD_LOW	equ 0x00008000 ; TX Desc low threshold hit
   581                              <2> I8254X_ICR_SRPD		equ 0x00010000 ; Small RX packet detected
   582                              <2> 
   583                              <2> ; RCTL - Receive Control Register (0x0100)
   584                              <2> I8254X_RCTL_EN		equ 0x00000002 ; Receiver Enable
   585                              <2> I8254X_RCTL_SBP		equ 0x00000004 ; Store Bad Packets
   586                              <2> I8254X_RCTL_UPE		equ 0x00000008 ; Unicast Promiscuous Enabled
   587                              <2> I8254X_RCTL_MPE		equ 0x00000010 ; Xcast Promiscuous Enabled
   588                              <2> I8254X_RCTL_LPE		equ 0x00000020 ; Long Packet Reception Enable
   589                              <2> I8254X_RCTL_LBM_MASK	equ 0x000000C0 ; Loopback Mode
   590                              <2> I8254X_RCTL_LBM_SHIFT	equ 6
   591                              <2> I8254X_RCTL_RDMTS_MASK	equ 0x00000300 ; RX Desc Min Threshold Size
   592                              <2> I8254X_RCTL_RDMTS_SHIFT	equ 8
   593                              <2> I8254X_RCTL_MO_MASK	equ 0x00003000 ; Multicast Offset
   594                              <2> I8254X_RCTL_MO_SHIFT	equ 12
   595                              <2> I8254X_RCTL_BAM		equ 0x00008000 ; Broadcast Accept Mode
   596                              <2> I8254X_RCTL_BSIZE_MASK	equ 0x00030000 ; RX Buffer Size
   597                              <2> I8254X_RCTL_BSIZE_SHIFT	equ 16
   598                              <2> I8254X_RCTL_VFE		equ 0x00040000 ; VLAN Filter Enable
   599                              <2> I8254X_RCTL_CFIEN	equ 0x00080000 ; CFI Enable
   600                              <2> I8254X_RCTL_CFI		equ 0x00100000 ; Canonical Form Indicator Bit
   601                              <2> I8254X_RCTL_DPF		equ 0x00400000 ; Discard Pause Frames
   602                              <2> I8254X_RCTL_PMCF	equ 0x00800000 ; Pass MAC Control Frames
   603                              <2> I8254X_RCTL_BSEX	equ 0x02000000 ; Buffer Size Extension
   604                              <2> I8254X_RCTL_SECRC	equ 0x04000000 ; Strip Ethernet CRC
   605                              <2> 
   606                              <2> ; TCTL - Transmit Control Register (0x0400)
   607                              <2> I8254X_TCTL_EN		equ 0x00000002 ; Transmit Enable
   608                              <2> I8254X_TCTL_PSP		equ 0x00000008 ; Pad short packets
   609                              <2> I8254X_TCTL_SWXOFF	equ 0x00400000 ; Software XOFF Transmission
   610                              <2> 
   611                              <2> ; PBA - Packet Buffer Allocation (0x1000)
   612                              <2> I8254X_PBA_RXA_MASK	equ 0x0000FFFF ; RX Packet Buffer
   613                              <2> I8254X_PBA_RXA_SHIFT	equ 0
   614                              <2> I8254X_PBA_TXA_MASK	equ 0xFFFF0000 ; TX Packet Buffer
   615                              <2> I8254X_PBA_TXA_SHIFT	equ 16
   616                              <2> 
   617                              <2> ; Flow Control Type
   618                              <2> I8254X_FCT_TYPE_DEFAULT	equ 0x8808
   619                              <2> 
   620                              <2> ; === TX Descriptor fields ===
   621                              <2> 
   622                              <2> ; TX Packet Length (word 2)
   623                              <2> I8254X_TXDESC_LEN_MASK	equ 0x0000ffff
   624                              <2> 
   625                              <2> ; TX Descriptor CMD field (word 2)
   626                              <2> I8254X_TXDESC_IDE	equ 0x80000000 ; Interrupt Delay Enable
   627                              <2> I8254X_TXDESC_VLE	equ 0x40000000 ; VLAN Packet Enable
   628                              <2> I8254X_TXDESC_DEXT	equ 0x20000000 ; Extension
   629                              <2> I8254X_TXDESC_RPS	equ 0x10000000 ; Report Packet Sent
   630                              <2> I8254X_TXDESC_RS	equ 0x08000000 ; Report Status
   631                              <2> I8254X_TXDESC_IC	equ 0x04000000 ; Insert Checksum
   632                              <2> I8254X_TXDESC_IFCS	equ 0x02000000 ; Insert FCS
   633                              <2> I8254X_TXDESC_EOP	equ 0x01000000 ; End Of Packet
   634                              <2> 
   635                              <2> ; TX Descriptor STA field (word 3)
   636                              <2> I8254X_TXDESC_TU	equ 0x00000008 ; Transmit Underrun
   637                              <2> I8254X_TXDESC_LC	equ 0x00000004 ; Late Collision
   638                              <2> I8254X_TXDESC_EC	equ 0x00000002 ; Excess Collisions
   639                              <2> I8254X_TXDESC_DD	equ 0x00000001 ; Descriptor Done
   640                              <2> 
   641                              <2> ; === RX Descriptor fields ===
   642                              <2> 
   643                              <2> ; RX Packet Length (word 2)
   644                              <2> I8254X_RXDESC_LEN_MASK	equ 0x0000ffff
   645                              <2> 
   646                              <2> ; RX Descriptor STA field (word 3)
   647                              <2> I8254X_RXDESC_PIF	equ 0x00000080 ; Passed In-exact Filter
   648                              <2> I8254X_RXDESC_IPCS	equ 0x00000040 ; IP cksum calculated
   649                              <2> I8254X_RXDESC_TCPCS	equ 0x00000020 ; TCP cksum calculated
   650                              <2> I8254X_RXDESC_VP	equ 0x00000008 ; Packet is 802.1Q
   651                              <2> I8254X_RXDESC_IXSM	equ 0x00000004 ; Ignore cksum indication
   652                              <2> I8254X_RXDESC_EOP	equ 0x00000002 ; End Of Packet
   653                              <2> I8254X_RXDESC_DD	equ 0x00000001 ; Descriptor Done
   654                              <2> 
   655                              <2> ; =============================================================================
   656                              <2> ; EOF
   185                              <1> %include "drivers/net/virtio.asm"
   186                              <2> ; =============================================================================
   187                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   188                              <2> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   189                              <2> ;
   190                              <2> ; Virtio NIC Driver
   191                              <2> ; =============================================================================
   192                              <2> 
   193                              <2> 
   194                              <2> ; -----------------------------------------------------------------------------
   195                              <2> ; Initialize a Virtio NIC
   196                              <2> ;  IN:	EDX = Packed PCI address (as per pci.asm)
   197                              <2> net_virtio_init:
   198 000010CF 56                  <2> 	push rsi
   199 000010D0 52                  <2> 	push rdx
   200 000010D1 51                  <2> 	push rcx
   201 000010D2 50                  <2> 	push rax
   202                              <2> 
   203                              <2> 	; Grab the Base I/O Address of the device
   204 000010D3 B204                <2> 	mov dl, 0x04			; BAR0
   205 000010D5 E885F9FFFF          <2> 	call os_pci_read
   206                              <2> 	; Todo: Make sure bit 0 is 1
   207 000010DA 83E0FC              <2> 	and eax, 0xFFFFFFFC		; Clear the low two bits
   208 000010DD 89042548001100      <2> 	mov dword [os_NetIOBaseMem], eax
   209                              <2> 
   210                              <2> 	; Grab the IRQ of the device
   211 000010E4 B20F                <2> 	mov dl, 0x0F			; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
   212 000010E6 E874F9FFFF          <2> 	call os_pci_read
   213 000010EB 8804250A031100      <2> 	mov [os_NetIRQ], al		; AL holds the IRQ
   214                              <2> 
   215                              <2> 	; Grab the MAC address
   216 000010F2 8B142548001100      <2> 	mov edx, [os_NetIOBaseMem]
   217 000010F9 83C214              <2> 	add edx, 0x14
   218 000010FC EC                  <2> 	in al, dx
   219 000010FD 88042550001100      <2> 	mov [os_NetMAC], al
   220 00001104 66FFC2              <2> 	inc dx
   221 00001107 EC                  <2> 	in al, dx
   222 00001108 88042551001100      <2> 	mov [os_NetMAC+1], al
   223 0000110F 66FFC2              <2> 	inc dx
   224 00001112 EC                  <2> 	in al, dx
   225 00001113 88042552001100      <2> 	mov [os_NetMAC+2], al
   226 0000111A 66FFC2              <2> 	inc dx
   227 0000111D EC                  <2> 	in al, dx
   228 0000111E 88042553001100      <2> 	mov [os_NetMAC+3], al
   229 00001125 66FFC2              <2> 	inc dx
   230 00001128 EC                  <2> 	in al, dx
   231 00001129 88042554001100      <2> 	mov [os_NetMAC+4], al
   232 00001130 66FFC2              <2> 	inc dx
   233 00001133 EC                  <2> 	in al, dx
   234 00001134 88042555001100      <2> 	mov [os_NetMAC+5], al
   235                              <2> 
   236                              <2> ;	jmp $
   237                              <2> 
   238                              <2> 	; Reset the device
   239 0000113B E805000000          <2> 	call net_virtio_reset
   240                              <2> 
   241 00001140 58                  <2> 	pop rax
   242 00001141 59                  <2> 	pop rcx
   243 00001142 5A                  <2> 	pop rdx
   244 00001143 5E                  <2> 	pop rsi
   245 00001144 C3                  <2> 	ret
   246                              <2> ; -----------------------------------------------------------------------------
   247                              <2> 
   248                              <2> 
   249                              <2> ; -----------------------------------------------------------------------------
   250                              <2> ; net_virtio_reset - Reset a Virtio NIC
   251                              <2> ;  IN:	Nothing
   252                              <2> ; OUT:	Nothing, all registers preserved
   253                              <2> net_virtio_reset:
   254                              <2> 
   255                              <2> 
   256                              <2> ; Acknowledge
   257                              <2> 
   258                              <2> ; Driver
   259                              <2> 
   260                              <2> ; Queue
   261                              <2> 
   262 00001145 C3                  <2> 	ret
   263                              <2> ; -----------------------------------------------------------------------------
   264                              <2> 
   265                              <2> 
   266                              <2> ; -----------------------------------------------------------------------------
   267                              <2> ; net_virtio_transmit - Transmit a packet via a Virtio NIC
   268                              <2> ;  IN:	RSI = Location of packet
   269                              <2> ;	RCX = Length of packet
   270                              <2> ; OUT:	Nothing
   271                              <2> net_virtio_transmit:
   272                              <2> 
   273 00001146 C3                  <2> 	ret
   274                              <2> ; -----------------------------------------------------------------------------
   275                              <2> 
   276                              <2> 
   277                              <2> ; -----------------------------------------------------------------------------
   278                              <2> ; net_virtio_poll - Polls the Virtio NIC for a received packet
   279                              <2> ;  IN:	RDI = Location to store packet
   280                              <2> ; OUT:	RCX = Length of packet
   281                              <2> net_virtio_poll:
   282                              <2> 
   283 00001147 C3                  <2> 	ret
   284                              <2> ; -----------------------------------------------------------------------------
   285                              <2> 
   286                              <2> 
   287                              <2> ; -----------------------------------------------------------------------------
   288                              <2> ; net_virtio_ack_int - Acknowledge an internal interrupt of the Virtio NIC
   289                              <2> ;  IN:	Nothing
   290                              <2> ; OUT:	RAX = Ethernet status
   291                              <2> ;	Uses RDI
   292                              <2> net_virtio_ack_int:
   293                              <2> 
   294 00001148 C3                  <2> 	ret
   295                              <2> ; -----------------------------------------------------------------------------
   296                              <2> 
   297                              <2> 
   298                              <2> ; =============================================================================
   299                              <2> ; EOF
   186                              <1> 
   187                              <1> 
   188                              <1> NIC_DeviceVendor_ID:	; The supported list of NICs
   189                              <1> ; The ID's are Device/Vendor
   190                              <1> 
   191                              <1> ; Virtio
   192 00001149 FFFFF41A            <1> dd 0x1AF4FFFF		; Driver marker
   193 0000114D F41A0010            <1> dd 0x10001AF4
   194                              <1> 
   195                              <1> ; Intel 8254x Gigabit Ethernet
   196 00001151 FFFF5482            <1> dd 0x8254FFFF		; Driver marker
   197 00001155 86800010            <1> dd 0x10008086		; 82542 (Fiber)
   198 00001159 86800110            <1> dd 0x10018086		; 82543GC (Fiber)
   199 0000115D 86800410            <1> dd 0x10048086		; 82543GC (Copper)
   200 00001161 86800810            <1> dd 0x10088086		; 82544EI (Copper)
   201 00001165 86800910            <1> dd 0x10098086		; 82544EI (Fiber)
   202 00001169 86800A10            <1> dd 0x100A8086		; 82540EM
   203 0000116D 86800C10            <1> dd 0x100C8086		; 82544GC (Copper)
   204 00001171 86800D10            <1> dd 0x100D8086		; 82544GC (LOM)
   205 00001175 86800E10            <1> dd 0x100E8086		; 82540EM
   206 00001179 86800F10            <1> dd 0x100F8086		; 82545EM (Copper)
   207 0000117D 86801010            <1> dd 0x10108086		; 82546EB (Copper)
   208 00001181 86801110            <1> dd 0x10118086		; 82545EM (Fiber)
   209 00001185 86801210            <1> dd 0x10128086		; 82546EB (Fiber)
   210 00001189 86801310            <1> dd 0x10138086		; 82541EI
   211 0000118D 86801410            <1> dd 0x10148086		; 82541ER
   212 00001191 86801510            <1> dd 0x10158086		; 82540EM (LOM)
   213 00001195 86801610            <1> dd 0x10168086		; 82540EP (Mobile)
   214 00001199 86801710            <1> dd 0x10178086		; 82540EP
   215 0000119D 86801810            <1> dd 0x10188086		; 82541EI
   216 000011A1 86801910            <1> dd 0x10198086		; 82547EI
   217 000011A5 86801A10            <1> dd 0x101a8086		; 82547EI (Mobile)
   218 000011A9 86801D10            <1> dd 0x101d8086		; 82546EB
   219 000011AD 86801E10            <1> dd 0x101e8086		; 82540EP (Mobile)
   220 000011B1 86802610            <1> dd 0x10268086		; 82545GM
   221 000011B5 86802710            <1> dd 0x10278086		; 82545GM
   222 000011B9 86802810            <1> dd 0x10288086		; 82545GM
   223 000011BD 86805B10            <1> dd 0x105b8086		; 82546GB (Copper)
   224 000011C1 86807510            <1> dd 0x10758086		; 82547GI
   225 000011C5 86807610            <1> dd 0x10768086		; 82541GI
   226 000011C9 86807710            <1> dd 0x10778086		; 82541GI
   227 000011CD 86807810            <1> dd 0x10788086		; 82541ER
   228 000011D1 86807910            <1> dd 0x10798086		; 82546GB
   229 000011D5 86807A10            <1> dd 0x107a8086		; 82546GB
   230 000011D9 86807B10            <1> dd 0x107b8086		; 82546GB
   231 000011DD 86807C10            <1> dd 0x107c8086		; 82541PI
   232 000011E1 8680B510            <1> dd 0x10b58086		; 82546GB (Copper)
   233 000011E5 86800711            <1> dd 0x11078086		; 82544EI
   234 000011E9 86801211            <1> dd 0x11128086		; 82544GC
   235                              <1> 
   236 000011ED 0000000000000000    <1> dq 0x0000000000000000	; End of list
   237                              <1> 
   238                              <1> 
   239                              <1> ; =============================================================================
   240                              <1> ; EOF
   168                                  %include "interrupt.asm"
   169                              <1> ; =============================================================================
   170                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   171                              <1> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   172                              <1> ;
   173                              <1> ; Interrupts
   174                              <1> ; =============================================================================
   175                              <1> 
   176                              <1> 
   177                              <1> ; -----------------------------------------------------------------------------
   178                              <1> ; Default exception handler
   179 000011F5 90<rep 3h>          <1> align 8
   180                              <1> exception_gate:
   181 000011F8 48BE-               <1> 	mov rsi, int_string00
   181 000011FA [BF16000000000000]  <1>
   182 00001202 E879F5FFFF          <1> 	call b_output
   183 00001207 48BE-               <1> 	mov rsi, exc_string
   183 00001209 [E916000000000000]  <1>
   184 00001211 E86AF5FFFF          <1> 	call b_output
   185 00001216 EBFE                <1> 	jmp $				; Hang
   186                              <1> ; -----------------------------------------------------------------------------
   187                              <1> 
   188                              <1> 
   189                              <1> ; -----------------------------------------------------------------------------
   190                              <1> ; Default interrupt handler
   191                              <1> align 8
   192                              <1> interrupt_gate:				; handler for all other interrupts
   193 00001218 48CF                <1> 	iretq				; It was an undefined interrupt so return to caller
   194                              <1> ; -----------------------------------------------------------------------------
   195                              <1> 
   196                              <1> 
   197                              <1> ; -----------------------------------------------------------------------------
   198                              <1> ; Keyboard interrupt. IRQ 0x01, INT 0x21
   199                              <1> ; This IRQ runs whenever there is input on the keyboard
   200 0000121A 90<rep 6h>          <1> align 8
   201                              <1> keyboard:
   202 00001220 57                  <1> 	push rdi
   203 00001221 53                  <1> 	push rbx
   204 00001222 50                  <1> 	push rax
   205 00001223 9C                  <1> 	pushfq
   206 00001224 FC                  <1> 	cld				; Clear direction flag
   207                              <1> 
   208 00001225 31C0                <1> 	xor eax, eax
   209                              <1> 
   210 00001227 E460                <1> 	in al, 0x60			; Get the scan code from the keyboard
   211 00001229 3C01                <1> 	cmp al, 0x01
   212 0000122B 7444                <1> 	je keyboard_escape
   213 0000122D 3C2A                <1> 	cmp al, 0x2A			; Left Shift Make
   214 0000122F 7447                <1> 	je keyboard_shift
   215 00001231 3C36                <1> 	cmp al, 0x36			; Right Shift Make
   216 00001233 7443                <1> 	je keyboard_shift
   217 00001235 3CAA                <1> 	cmp al, 0xAA			; Left Shift Break
   218 00001237 7449                <1> 	je keyboard_noshift
   219 00001239 3CB6                <1> 	cmp al, 0xB6			; Right Shift Break
   220 0000123B 7445                <1> 	je keyboard_noshift
   221 0000123D A880                <1> 	test al, 0x80
   222 0000123F 7402                <1> 	jz keydown
   223 00001241 EB33                <1> 	jmp keyup
   224                              <1> 
   225                              <1> keydown:
   226 00001243 803C250403110000    <1> 	cmp byte [key_shift], 0x00
   227 0000124B 740C                <1> 	je keyboard_lowercase
   228                              <1> 
   229                              <1>  keyboard_uppercase:
   230 0000124D 48BB-               <1> 	mov rbx, keylayoutupper
   230 0000124F [1B18000000000000]  <1>
   231 00001257 EB0A                <1> 	jmp keyboard_processkey
   232                              <1> 
   233                              <1>  keyboard_lowercase:
   234 00001259 48BB-               <1> 	mov rbx, keylayoutlower
   234 0000125B [E017000000000000]  <1>
   235                              <1> 
   236                              <1>  keyboard_processkey:			; Convert the scan code
   237 00001263 4801C3              <1> 	add rbx, rax
   238 00001266 8A1B                <1> 	mov bl, [rbx]
   239 00001268 881C2503031100      <1> 	mov [key], bl
   240 0000126F EB1B                <1> 	jmp keyboard_done
   241                              <1> 
   242                              <1>  keyboard_escape:
   243 00001271 E9DDF7FFFF          <1> 	jmp reboot
   244                              <1> 
   245                              <1> keyup:
   246 00001276 EB14                <1> 	jmp keyboard_done
   247                              <1> 
   248                              <1>  keyboard_shift:
   249 00001278 C604250403110001    <1> 	mov byte [key_shift], 0x01
   250 00001280 EB0A                <1> 	jmp keyboard_done
   251                              <1> 
   252                              <1>  keyboard_noshift:
   253 00001282 C604250403110000    <1> 	mov byte [key_shift], 0x00
   254 0000128A EB00                <1> 	jmp keyboard_done
   255                              <1> 
   256                              <1>  keyboard_done:
   257 0000128C B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
   258 0000128E E620                <1> 	out 0x20, al
   259 00001290 E814F6FFFF          <1> 	call b_smp_wakeup_all		; A terrible hack
   260                              <1> 
   261 00001295 9D                  <1> 	popfq
   262 00001296 58                  <1> 	pop rax
   263 00001297 5B                  <1> 	pop rbx
   264 00001298 5F                  <1> 	pop rdi
   265 00001299 48CF                <1> 	iretq
   266                              <1> ; -----------------------------------------------------------------------------
   267                              <1> 
   268                              <1> 
   269                              <1> ; -----------------------------------------------------------------------------
   270                              <1> ; Cascade interrupt. IRQ 0x02, INT 0x22
   271 0000129B 90<rep 5h>          <1> align 8
   272                              <1> cascade:
   273 000012A0 50                  <1> 	push rax
   274                              <1> 
   275 000012A1 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
   276 000012A3 E620                <1> 	out 0x20, al
   277                              <1> 
   278 000012A5 58                  <1> 	pop rax
   279 000012A6 48CF                <1> 	iretq
   280                              <1> ; -----------------------------------------------------------------------------
   281                              <1> 
   282                              <1> 
   283                              <1> ; -----------------------------------------------------------------------------
   284                              <1> ; Real-time clock interrupt. IRQ 0x08, INT 0x28
   285                              <1> ; Currently this IRQ runs 8 times per second (As defined in init_64.asm)
   286                              <1> ; The supervisor lives here
   287                              <1> align 8
   288                              <1> rtc:
   289 000012A8 50                  <1> 	push rax
   290 000012A9 9C                  <1> 	pushfq
   291 000012AA FC                  <1> 	cld				; Clear direction flag
   292                              <1> 
   293 000012AB 488304251000110001  <1> 	add qword [os_ClockCounter], 1	; 64-bit counter started at boot-up
   294                              <1> 
   295 000012B4 48833C258000110000  <1> 	cmp qword [os_ClockCallback], 0	; Is it valid?
   296 000012BD 743B                <1> 	je rtc_end			; If not then bail out.
   297                              <1> 
   298                              <1> 	; We could do a 'call [os_ClockCallback]' here but that would not be ideal.
   299                              <1> 	; A defective callback would hang the system if it never returned back to the
   300                              <1> 	; interrupt handler. Instead, we modify the stack so that the callback is
   301                              <1> 	; executed after the interrupt handler has finished. Once the callback has
   302                              <1> 	; finished, the execution flow will pick up back in the program.
   303 000012BF 57                  <1> 	push rdi
   304 000012C0 56                  <1> 	push rsi
   305 000012C1 51                  <1> 	push rcx
   306 000012C2 48B9-               <1> 	mov rcx, clock_callback		; RCX stores the callback function address
   306 000012C4 [B013000000000000]  <1>
   307 000012CC 4889E6              <1> 	mov rsi, rsp			; Copy the current stack pointer to RSI
   308 000012CF 4883EC08            <1> 	sub rsp, 8			; Subtract 8 since we add a 64-bit value to the stack
   309 000012D3 4889E7              <1> 	mov rdi, rsp			; Copy the 'new' stack pointer to RDI
   310 000012D6 48A5                <1> 	movsq				; RCX
   311 000012D8 48A5                <1> 	movsq				; RSI
   312 000012DA 48A5                <1> 	movsq				; RDI
   313 000012DC 48A5                <1> 	movsq				; Flags
   314 000012DE 48A5                <1> 	movsq				; RAX
   315 000012E0 48AD                <1> 	lodsq				; RIP
   316 000012E2 4891                <1> 	xchg rax, rcx
   317 000012E4 48AB                <1> 	stosq				; Callback address
   318 000012E6 48A5                <1> 	movsq				; CS
   319 000012E8 48A5                <1> 	movsq				; Flags
   320 000012EA 48AD                <1> 	lodsq				; RSP
   321 000012EC 4883E808            <1> 	sub rax, 8
   322 000012F0 48AB                <1> 	stosq
   323 000012F2 48A5                <1> 	movsq				; SS
   324 000012F4 488908              <1> 	mov [rax], rcx			; Original RIP
   325 000012F7 59                  <1> 	pop rcx
   326 000012F8 5E                  <1> 	pop rsi
   327 000012F9 5F                  <1> 	pop rdi
   328                              <1> 
   329                              <1>  rtc_end:
   330 000012FA B00C                <1> 	mov al, 0x0C			; Select RTC register C
   331 000012FC E670                <1> 	out 0x70, al			; Port 0x70 is the RTC index, and 0x71 is the RTC data
   332 000012FE E471                <1> 	in al, 0x71			; Read the value in register C
   333                              <1> 
   334 00001300 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
   335 00001302 E6A0                <1> 	out 0xA0, al
   336 00001304 E620                <1> 	out 0x20, al
   337                              <1> 
   338 00001306 9D                  <1> 	popfq
   339 00001307 58                  <1> 	pop rax
   340 00001308 48CF                <1> 	iretq
   341                              <1> ; -----------------------------------------------------------------------------
   342                              <1> 
   343                              <1> 
   344                              <1> ; -----------------------------------------------------------------------------
   345                              <1> ; Network interrupt handler
   346 0000130A 90<rep 6h>          <1> align 8
   347                              <1> network:
   348 00001310 57                  <1> 	push rdi
   349 00001311 56                  <1> 	push rsi
   350 00001312 51                  <1> 	push rcx
   351 00001313 50                  <1> 	push rax
   352 00001314 9C                  <1> 	pushfq
   353 00001315 FC                  <1> 	cld				; Clear direction flag
   354                              <1> 
   355 00001316 E82DF5FFFF          <1> 	call b_net_ack_int		; Call the driver function to acknowledge the interrupt internally
   356                              <1> 
   357 0000131B 660FBAE000          <1> 	bt ax, 0			; TX bit set (caused the IRQ?)
   358 00001320 7256                <1> 	jc network_tx			; If so then jump past RX section
   359 00001322 660FBAE007          <1> 	bt ax, 7			; RX bit set
   360 00001327 735E                <1> 	jnc network_end
   361                              <1>  network_rx_as_well:
   362 00001329 C604250C03110001    <1> 	mov byte [os_NetActivity_RX], 1
   363 00001331 E81AF5FFFF          <1> 	call b_net_rx_from_interrupt	; Call driver
   364 00001336 48833C256800110000  <1> 	cmp qword [os_NetworkCallback], 0	; Is it valid?
   365 0000133F 7446                <1> 	je network_end			; If not then bail out.
   366                              <1> 
   367                              <1> 	; We could do a 'call [os_NetworkCallback]' here but that would not be ideal.
   368                              <1> 	; A defective callback would hang the system if it never returned back to the
   369                              <1> 	; interrupt handler. Instead, we modify the stack so that the callback is
   370                              <1> 	; executed after the interrupt handler has finished. Once the callback has
   371                              <1> 	; finished, the execution flow will pick up back in the program.
   372 00001341 48B9-               <1> 	mov rcx, network_callback	; RCX stores the callback function address
   372 00001343 [A013000000000000]  <1>
   373 0000134B 4889E6              <1> 	mov rsi, rsp			; Copy the current stack pointer to RSI
   374 0000134E 4883EC08            <1> 	sub rsp, 8			; Subtract 8 since we add a 64-bit value to the stack
   375 00001352 4889E7              <1> 	mov rdi, rsp			; Copy the 'new' stack pointer to RDI
   376 00001355 48A5                <1> 	movsq				; Flags
   377 00001357 48A5                <1> 	movsq				; RAX
   378 00001359 48A5                <1> 	movsq				; RCX
   379 0000135B 48A5                <1> 	movsq				; RSI
   380 0000135D 48A5                <1> 	movsq				; RDI
   381 0000135F 48AD                <1> 	lodsq				; RIP
   382 00001361 4891                <1> 	xchg rax, rcx
   383 00001363 48AB                <1> 	stosq				; Callback address
   384 00001365 48A5                <1> 	movsq				; CS
   385 00001367 48A5                <1> 	movsq				; Flags
   386 00001369 48AD                <1> 	lodsq				; RSP
   387 0000136B 4883E808            <1> 	sub rax, 8
   388 0000136F 48AB                <1> 	stosq
   389 00001371 48A5                <1> 	movsq				; SS
   390 00001373 488908              <1> 	mov [rax], rcx			; Original RIP
   391 00001376 EB0F                <1> 	jmp network_end
   392                              <1> 
   393                              <1>  network_tx:
   394 00001378 C604250B03110001    <1> 	mov byte [os_NetActivity_TX], 1
   395 00001380 660FBAE007          <1> 	bt ax, 7
   396 00001385 72A2                <1> 	jc network_rx_as_well
   397                              <1> 
   398                              <1>  network_end:
   399 00001387 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ on the PIC(s)
   400 00001389 803C250A03110008    <1> 	cmp byte [os_NetIRQ], 8
   401 00001391 7C02                <1> 	jl network_ack_only_low		; If the network IRQ is less than 8 then the other PIC does not need to be ack'ed
   402 00001393 E6A0                <1> 	out 0xA0, al
   403                              <1>  network_ack_only_low:
   404 00001395 E620                <1> 	out 0x20, al
   405                              <1> 
   406 00001397 9D                  <1> 	popfq
   407 00001398 58                  <1> 	pop rax
   408 00001399 59                  <1> 	pop rcx
   409 0000139A 5E                  <1> 	pop rsi
   410 0000139B 5F                  <1> 	pop rdi
   411 0000139C 48CF                <1> 	iretq
   412                              <1> ; -----------------------------------------------------------------------------
   413                              <1> 
   414                              <1> 
   415                              <1> ; -----------------------------------------------------------------------------
   416                              <1> ; Network interrupt callback.
   417 0000139E 90<rep 2h>          <1> align 8
   418                              <1> network_callback:
   419 000013A0 9C                  <1> 	pushfq
   420 000013A1 FC                  <1> 	cld				; Clear direction flag
   421 000013A2 FF142568001100      <1> 	call [os_NetworkCallback]
   422 000013A9 9D                  <1> 	popfq
   423 000013AA C3                  <1> 	ret
   424                              <1> ; -----------------------------------------------------------------------------
   425                              <1> 
   426                              <1> 
   427                              <1> ; -----------------------------------------------------------------------------
   428                              <1> ; Clock interrupt callback.
   429 000013AB 90<rep 5h>          <1> align 8
   430                              <1> clock_callback:
   431 000013B0 9C                  <1> 	pushfq
   432 000013B1 FC                  <1> 	cld				; Clear direction flag
   433 000013B2 FF142580001100      <1> 	call [os_ClockCallback]
   434 000013B9 9D                  <1> 	popfq
   435 000013BA C3                  <1> 	ret
   436                              <1> ; -----------------------------------------------------------------------------
   437                              <1> 
   438                              <1> 
   439                              <1> ; -----------------------------------------------------------------------------
   440                              <1> ; A simple interrupt that just acknowledges an IPI. Useful for getting an AP past a 'hlt' in the code.
   441 000013BB 90<rep 5h>          <1> align 8
   442                              <1> ap_wakeup:
   443 000013C0 57                  <1> 	push rdi
   444 000013C1 50                  <1> 	push rax
   445                              <1> 
   446 000013C2 488B3C2500001100    <1> 	mov rdi, [os_LocalAPICAddress]	; Acknowledge the IPI
   447 000013CA 4881C7B0000000      <1> 	add rdi, 0xB0
   448 000013D1 31C0                <1> 	xor eax, eax
   449 000013D3 AB                  <1> 	stosd
   450                              <1> 
   451 000013D4 58                  <1> 	pop rax
   452 000013D5 5F                  <1> 	pop rdi
   453 000013D6 48CF                <1> 	iretq				; Return from the IPI.
   454                              <1> ; -----------------------------------------------------------------------------
   455                              <1> 
   456                              <1> 
   457                              <1> ; -----------------------------------------------------------------------------
   458                              <1> ; Resets a CPU to execute ap_clear
   459                              <1> align 8
   460                              <1> ap_reset:
   461 000013D8 48B8-               <1> 	mov rax, ap_clear		; Set RAX to the address of ap_clear
   461 000013DA [6001000000000000]  <1>
   462 000013E2 48890424            <1> 	mov [rsp], rax			; Overwrite the return address on the CPU's stack
   463 000013E6 488B3C2500001100    <1> 	mov rdi, [os_LocalAPICAddress]	; Acknowledge the IPI
   464 000013EE 4881C7B0000000      <1> 	add rdi, 0xB0
   465 000013F5 31C0                <1> 	xor eax, eax
   466 000013F7 AB                  <1> 	stosd
   467 000013F8 48CF                <1> 	iretq				; Return from the IPI. CPU will execute code at ap_clear
   468                              <1> ; -----------------------------------------------------------------------------
   469                              <1> 
   470                              <1> 
   471                              <1> ; -----------------------------------------------------------------------------
   472                              <1> ; CPU Exception Gates
   473 000013FA 90<rep 6h>          <1> align 8
   474                              <1> exception_gate_00:
   475 00001400 48894424F0          <1> 	mov [rsp-16], rax
   476 00001405 31C0                <1> 	xor eax, eax
   477 00001407 48894424F8          <1> 	mov [rsp-8], rax
   478 0000140C 4883EC10            <1> 	sub rsp, 16
   479 00001410 B000                <1> 	mov al, 0x00
   480 00001412 E9E1010000          <1> 	jmp exception_gate_main
   481                              <1> 
   482 00001417 90                  <1> align 8
   483                              <1> exception_gate_01:
   484 00001418 48894424F0          <1> 	mov [rsp-16], rax
   485 0000141D 31C0                <1> 	xor eax, eax
   486 0000141F 48894424F8          <1> 	mov [rsp-8], rax
   487 00001424 4883EC10            <1> 	sub rsp, 16
   488 00001428 B001                <1> 	mov al, 0x01
   489 0000142A E9C9010000          <1> 	jmp exception_gate_main
   490                              <1> 
   491 0000142F 90                  <1> align 8
   492                              <1> exception_gate_02:
   493 00001430 48894424F0          <1> 	mov [rsp-16], rax
   494 00001435 31C0                <1> 	xor eax, eax
   495 00001437 48894424F8          <1> 	mov [rsp-8], rax
   496 0000143C 4883EC10            <1> 	sub rsp, 16
   497 00001440 B002                <1> 	mov al, 0x02
   498 00001442 E9B1010000          <1> 	jmp exception_gate_main
   499                              <1> 
   500 00001447 90                  <1> align 8
   501                              <1> exception_gate_03:
   502 00001448 48894424F0          <1> 	mov [rsp-16], rax
   503 0000144D 31C0                <1> 	xor eax, eax
   504 0000144F 48894424F8          <1> 	mov [rsp-8], rax
   505 00001454 4883EC10            <1> 	sub rsp, 16
   506 00001458 B003                <1> 	mov al, 0x03
   507 0000145A E999010000          <1> 	jmp exception_gate_main
   508                              <1> 
   509 0000145F 90                  <1> align 8
   510                              <1> exception_gate_04:
   511 00001460 48894424F0          <1> 	mov [rsp-16], rax
   512 00001465 31C0                <1> 	xor eax, eax
   513 00001467 48894424F8          <1> 	mov [rsp-8], rax
   514 0000146C 4883EC10            <1> 	sub rsp, 16
   515 00001470 B004                <1> 	mov al, 0x04
   516 00001472 E981010000          <1> 	jmp exception_gate_main
   517                              <1> 
   518 00001477 90                  <1> align 8
   519                              <1> exception_gate_05:
   520 00001478 48894424F0          <1> 	mov [rsp-16], rax
   521 0000147D 31C0                <1> 	xor eax, eax
   522 0000147F 48894424F8          <1> 	mov [rsp-8], rax
   523 00001484 4883EC10            <1> 	sub rsp, 16
   524 00001488 B005                <1> 	mov al, 0x05
   525 0000148A E969010000          <1> 	jmp exception_gate_main
   526                              <1> 
   527 0000148F 90                  <1> align 8
   528                              <1> exception_gate_06:
   529 00001490 48894424F0          <1> 	mov [rsp-16], rax
   530 00001495 31C0                <1> 	xor eax, eax
   531 00001497 48894424F8          <1> 	mov [rsp-8], rax
   532 0000149C 4883EC10            <1> 	sub rsp, 16
   533 000014A0 B006                <1> 	mov al, 0x06
   534 000014A2 E951010000          <1> 	jmp exception_gate_main
   535                              <1> 
   536 000014A7 90                  <1> align 8
   537                              <1> exception_gate_07:
   538 000014A8 48894424F0          <1> 	mov [rsp-16], rax
   539 000014AD 31C0                <1> 	xor eax, eax
   540 000014AF 48894424F8          <1> 	mov [rsp-8], rax
   541 000014B4 4883EC10            <1> 	sub rsp, 16
   542 000014B8 B007                <1> 	mov al, 0x07
   543 000014BA E939010000          <1> 	jmp exception_gate_main
   544                              <1> 
   545 000014BF 90                  <1> align 8
   546                              <1> exception_gate_08:
   547 000014C0 50                  <1> 	push rax
   548 000014C1 B008                <1> 	mov al, 0x08
   549 000014C3 E930010000          <1> 	jmp exception_gate_main
   550 000014C8 90<rep 10h>         <1> 	times 16 db 0x90
   551                              <1> 
   552                              <1> align 8
   553                              <1> exception_gate_09:
   554 000014D8 48894424F0          <1> 	mov [rsp-16], rax
   555 000014DD 31C0                <1> 	xor eax, eax
   556 000014DF 48894424F8          <1> 	mov [rsp-8], rax
   557 000014E4 4883EC10            <1> 	sub rsp, 16
   558 000014E8 B009                <1> 	mov al, 0x09
   559 000014EA E909010000          <1> 	jmp exception_gate_main
   560                              <1> 
   561 000014EF 90                  <1> align 8
   562                              <1> exception_gate_10:
   563 000014F0 50                  <1> 	push rax
   564 000014F1 B00A                <1> 	mov al, 0x0A
   565 000014F3 E900010000          <1> 	jmp exception_gate_main
   566 000014F8 90<rep 10h>         <1> 	times 16 db 0x90
   567                              <1> 
   568                              <1> align 8
   569                              <1> exception_gate_11:
   570 00001508 50                  <1> 	push rax
   571 00001509 B00B                <1> 	mov al, 0x0B
   572 0000150B E9E8000000          <1> 	jmp exception_gate_main
   573 00001510 90<rep 10h>         <1> 	times 16 db 0x90
   574                              <1> 
   575                              <1> align 8
   576                              <1> exception_gate_12:
   577 00001520 50                  <1> 	push rax
   578 00001521 B00C                <1> 	mov al, 0x0C
   579 00001523 E9D0000000          <1> 	jmp exception_gate_main
   580 00001528 90<rep 10h>         <1> 	times 16 db 0x90
   581                              <1> 
   582                              <1> align 8
   583                              <1> exception_gate_13:
   584 00001538 50                  <1> 	push rax
   585 00001539 B00D                <1> 	mov al, 0x0D
   586 0000153B E9B8000000          <1> 	jmp exception_gate_main
   587 00001540 90<rep 10h>         <1> 	times 16 db 0x90
   588                              <1> 
   589                              <1> align 8
   590                              <1> exception_gate_14:
   591 00001550 50                  <1> 	push rax
   592 00001551 B00E                <1> 	mov al, 0x0E
   593 00001553 E9A0000000          <1> 	jmp exception_gate_main
   594 00001558 90<rep 10h>         <1> 	times 16 db 0x90
   595                              <1> 
   596                              <1> align 8
   597                              <1> exception_gate_15:
   598 00001568 48894424F0          <1> 	mov [rsp-16], rax
   599 0000156D 31C0                <1> 	xor eax, eax
   600 0000156F 48894424F8          <1> 	mov [rsp-8], rax
   601 00001574 4883EC10            <1> 	sub rsp, 16
   602 00001578 B00F                <1> 	mov al, 0x0F
   603 0000157A EB7C                <1> 	jmp exception_gate_main
   604                              <1> 
   605 0000157C 90<rep 4h>          <1> align 8
   606                              <1> exception_gate_16:
   607 00001580 48894424F0          <1> 	mov [rsp-16], rax
   608 00001585 31C0                <1> 	xor eax, eax
   609 00001587 48894424F8          <1> 	mov [rsp-8], rax
   610 0000158C 4883EC10            <1> 	sub rsp, 16
   611 00001590 B010                <1> 	mov al, 0x10
   612 00001592 EB64                <1> 	jmp exception_gate_main
   613                              <1> 
   614 00001594 90<rep 4h>          <1> align 8
   615                              <1> exception_gate_17:
   616 00001598 50                  <1> 	push rax
   617 00001599 B011                <1> 	mov al, 0x11
   618 0000159B EB5B                <1> 	jmp exception_gate_main
   619 0000159D 90<rep 10h>         <1> 	times 16 db 0x90
   620                              <1> 
   621 000015AD 90<rep 3h>          <1> align 8
   622                              <1> exception_gate_18:
   623 000015B0 48894424F0          <1> 	mov [rsp-16], rax
   624 000015B5 31C0                <1> 	xor eax, eax
   625 000015B7 48894424F8          <1> 	mov [rsp-8], rax
   626 000015BC 4883EC10            <1> 	sub rsp, 16
   627 000015C0 B012                <1> 	mov al, 0x12
   628 000015C2 EB34                <1> 	jmp exception_gate_main
   629                              <1> 
   630 000015C4 90<rep 4h>          <1> align 8
   631                              <1> exception_gate_19:
   632 000015C8 48894424F0          <1> 	mov [rsp-16], rax
   633 000015CD 31C0                <1> 	xor eax, eax
   634 000015CF 48894424F8          <1> 	mov [rsp-8], rax
   635 000015D4 4883EC10            <1> 	sub rsp, 16
   636 000015D8 B013                <1> 	mov al, 0x13
   637 000015DA EB1C                <1> 	jmp exception_gate_main
   638                              <1> 
   639 000015DC 90<rep 4h>          <1> align 8
   640                              <1> exception_gate_20:
   641 000015E0 48894424F0          <1> 	mov [rsp-16], rax
   642 000015E5 31C0                <1> 	xor eax, eax
   643 000015E7 48894424F8          <1> 	mov [rsp-8], rax
   644 000015EC 4883EC10            <1> 	sub rsp, 16
   645 000015F0 B014                <1> 	mov al, 0x14
   646 000015F2 EB04                <1> 	jmp exception_gate_main
   647                              <1> 
   648 000015F4 90<rep 4h>          <1> align 8
   649                              <1> exception_gate_main:
   650 000015F8 48C704256800110000- <1> 	mov qword [os_NetworkCallback], 0	; Reset the network callback
   650 00001601 000000              <1>
   651 00001604 48C704258000110000- <1> 	mov qword [os_ClockCallback], 0		; Reset the clock callback
   651 0000160D 000000              <1>
   652 00001610 53                  <1> 	push rbx
   653 00001611 57                  <1> 	push rdi
   654 00001612 56                  <1> 	push rsi
   655 00001613 51                  <1> 	push rcx			; Char counter for b_output
   656 00001614 50                  <1> 	push rax			; Save RAX since b_smp_get_id clobbers it
   657 00001615 48BE-               <1> 	mov rsi, newline
   657 00001617 [A617000000000000]  <1>
   658 0000161F B901000000          <1> 	mov rcx, 1
   659 00001624 E857F1FFFF          <1> 	call b_output
   660 00001629 48BE-               <1> 	mov rsi, int_string00
   660 0000162B [BF16000000000000]  <1>
   661 00001633 B918000000          <1> 	mov rcx, 24
   662 00001638 E843F1FFFF          <1> 	call b_output
   663 0000163D E887F2FFFF          <1> 	call b_smp_get_id		; Get the local CPU ID and print it
   664 00001642 E8C1EFFFFF          <1> 	call os_debug_dump_ax
   665 00001647 48BE-               <1> 	mov rsi, int_string01
   665 00001649 [D716000000000000]  <1>
   666 00001651 B90D000000          <1> 	mov rcx, 13
   667 00001656 E825F1FFFF          <1> 	call b_output
   668 0000165B 48BE-               <1> 	mov rsi, exc_string00
   668 0000165D [0117000000000000]  <1>
   669 00001665 58                  <1> 	pop rax
   670 00001666 4825FF000000        <1> 	and rax, 0x00000000000000FF	; Clear out everything in RAX except for AL
   671 0000166C 50                  <1> 	push rax
   672 0000166D B306                <1> 	mov bl, 6			; Length of each message
   673 0000166F F6E3                <1> 	mul bl				; AX = AL x BL
   674 00001671 4801C6              <1> 	add rsi, rax			; Use the value in RAX as an offset to get to the right message
   675 00001674 58                  <1> 	pop rax
   676 00001675 B30F                <1> 	mov bl, 0x0F
   677 00001677 B906000000          <1> 	mov rcx, 6
   678 0000167C E8FFF0FFFF          <1> 	call b_output
   679 00001681 59                  <1> 	pop rcx
   680 00001682 5E                  <1> 	pop rsi
   681 00001683 5F                  <1> 	pop rdi
   682 00001684 5B                  <1> 	pop rbx
   683 00001685 58                  <1> 	pop rax
   684 00001686 48BE-               <1> 	mov rsi, int_string02
   684 00001688 [E416000000000000]  <1>
   685 00001690 B905000000          <1> 	mov rcx, 5
   686 00001695 E8E6F0FFFF          <1> 	call b_output
   687 0000169A 488B442408          <1> 	mov rax, [rsp+8] 			; RIP of caller
   688 0000169F E829EFFFFF          <1> 	call os_debug_dump_rax
   689 000016A4 48BE-               <1> 	mov rsi, newline
   689 000016A6 [A617000000000000]  <1>
   690 000016AE B901000000          <1> 	mov rcx, 1
   691 000016B3 E8C8F0FFFF          <1> 	call b_output
   692 000016B8 EBFE                <1> 	jmp $				; For debugging
   693 000016BA E9A1EAFFFF          <1> 	jmp ap_clear			; jump to AP clear code
   694                              <1> 
   695                              <1> 
   696 000016BF 466174616C20457863- <1> int_string00 db 'Fatal Exception - CPU 0x'
   696 000016C8 657074696F6E202D20- <1>
   696 000016D1 435055203078        <1>
   697 000016D7 202D20496E74657272- <1> int_string01 db ' - Interrupt '
   697 000016E0 75707420            <1>
   698 000016E4 2040203078          <1> int_string02 db ' @ 0x'
   699                              <1> ; Strings for the error messages
   700 000016E9 556E6B6E6F776E2046- <1> exc_string db 'Unknown Fatal Exception!'
   700 000016F2 6174616C2045786365- <1>
   700 000016FB 7074696F6E21        <1>
   701 00001701 303028444529        <1> exc_string00 db '00(DE)'
   702 00001707 303128444229        <1> exc_string01 db '01(DB)'
   703 0000170D 303220202020        <1> exc_string02 db '02    '
   704 00001713 303328425029        <1> exc_string03 db '03(BP)'
   705 00001719 3034284F4629        <1> exc_string04 db '04(OF)'
   706 0000171F 303528425229        <1> exc_string05 db '05(BR)'
   707 00001725 303628554429        <1> exc_string06 db '06(UD)'
   708 0000172B 3037284E4D29        <1> exc_string07 db '07(NM)'
   709 00001731 303828444629        <1> exc_string08 db '08(DF)'
   710 00001737 303920202020        <1> exc_string09 db '09    '	; No longer generated on new CPU's
   711 0000173D 313028545329        <1> exc_string10 db '10(TS)'
   712 00001743 3131284E5029        <1> exc_string11 db '11(NP)'
   713 00001749 313228535329        <1> exc_string12 db '12(SS)'
   714 0000174F 313328475029        <1> exc_string13 db '13(GP)'
   715 00001755 313428504629        <1> exc_string14 db '14(PF)'
   716 0000175B 313520202020        <1> exc_string15 db '15    '
   717 00001761 3136284D4629        <1> exc_string16 db '16(MF)'
   718 00001767 313728414329        <1> exc_string17 db '17(AC)'
   719 0000176D 3138284D4329        <1> exc_string18 db '18(MC)'
   720 00001773 313928584D29        <1> exc_string19 db '19(XM)'
   721 00001779 323028564529        <1> exc_string20 db '20(VE)'
   722                              <1> 
   723                              <1> 
   724                              <1> ; =============================================================================
   725                              <1> ; EOF
   169                                  %include "sysvar.asm"			    ; Include this last to keep the read/write variables away from the code
   170                              <1> ; =============================================================================
   171                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   172                              <1> ; Copyright (C) 2008-2020 Return Infinity -- see LICENSE.TXT
   173                              <1> ;
   174                              <1> ; System Variables
   175                              <1> ; =============================================================================
   176                              <1> 
   177                              <1> 
   178                              <1> ; Constants
   179 0000177F 303132333435363738- <1> hextable: 		db '0123456789ABCDEF'
   179 00001788 39414243444546      <1>
   180                              <1> 
   181                              <1> 
   182                              <1> ; Strings
   183 0000178F 53696D704F53207630- <1> system_status_header:	db    'SimpOS v0.0.0', 0
   183 00001798 2E302E3000          <1>
   184 0000179D 53696D704F53204F4B  <1> readymsg:		db            'SimpOS OK'	; This string falls thru to newline
   185 000017A6 0A00                <1> newline:		db 10, 0
   186 000017A8 4E6F7420656E6F7567- <1> memory_message:		db 'Not enough system memory for CPU stacks! System halted.', 0
   186 000017B1 682073797374656D20- <1>
   186 000017BA 6D656D6F727920666F- <1>
   186 000017C3 722043505520737461- <1>
   186 000017CC 636B73212053797374- <1>
   186 000017D5 656D2068616C746564- <1>
   186 000017DE 2E00                <1>
   187                              <1> 
   188                              <1> ; Memory addresses
   189                              <1> sys_idt:		equ 0x0000000000000000	; 0x000000 -> 0x000FFF	4K Interrupt descriptor table
   190                              <1> sys_gdt:		equ 0x0000000000001000	; 0x001000 -> 0x001FFF	4K Global descriptor table
   191                              <1> sys_pml4:		equ 0x0000000000002000	; 0x002000 -> 0x002FFF	4K PML4 table
   192                              <1> sys_pdpl:		equ 0x0000000000003000	; 0x003000 -> 0x003FFF	4K PDP table low
   193                              <1> sys_pdph:		equ 0x0000000000004000	; 0x004000 -> 0x004FFF	4K PDP table high
   194                              <1> sys_Pure64:		equ 0x0000000000005000	; 0x005000 -> 0x007FFF	12K Pure64 system data
   195                              <1> 						; 0x008000 -> 0x00FFFF	32K Free
   196                              <1> sys_pdl:		equ 0x0000000000010000	; 0x010000 -> 0x01FFFF	64K Page directory low (Maps up to 16GB)
   197                              <1> sys_pdh:		equ 0x0000000000020000	; 0x020000 -> 0x05FFFF	256K Page directory high (Maps up to 64GB)
   198                              <1> 						; 0x060000 -> 0x09FFFF	256K Free
   199                              <1> sys_ROM:		equ 0x00000000000A0000	; 0x0A0000 -> 0x0FFFFF	384K System ROM
   200                              <1> os_KernelStart:		equ 0x0000000000100000	; 0x100000 -> 0x10FFFF	64K Kernel
   201                              <1> os_SystemVariables:	equ 0x0000000000110000	; 0x110000 -> 0x11FFFF	64K System Variables
   202                              <1> 						; 0x120000 -> 0x19FFFF	512K Free
   203                              <1> ahci_CLB:		equ 0x0000000000140000	; 0x140000 -> 0x147FFF	32K AHCI Command List Base (1K per port)
   204                              <1> ahci_FB:		equ 0x0000000000148000	; 0x148000 -> 0x167FFF	128K AHCI FIS Base (4K per port)
   205                              <1> ahci_CMD:		equ 0x0000000000168000	; 0x168000 -> 0x16FFFF	32K AHCI Commands
   206                              <1> 						; 0x170000 -> 0x19FFFF	192K Free
   207                              <1> os_rx_desc:		equ 0x00000000001A0000	; 0x1A0000 -> 0x1A7FFF	32K Ethernet receive descriptors
   208                              <1> os_tx_desc:		equ 0x00000000001A8000	; 0x1A8000 -> 0x1AFFFF	32K Ethernet transmit descriptors
   209                              <1> os_PacketBuffers:	equ 0x00000000001B0000	;
   210                              <1> os_SMP:			equ 0x00000000001FF800	; SMP table. Each item is 8 bytes. (2KiB before the 2MiB mark, Room for 256 entries)
   211                              <1> app_start:		equ 0xFFFF800000000000	; Location of application memory
   212                              <1> 
   213                              <1> ; DQ - Starting at offset 0, increments by 8
   214                              <1> os_LocalAPICAddress:	equ os_SystemVariables + 0
   215                              <1> os_IOAPICAddress:	equ os_SystemVariables + 8
   216                              <1> os_ClockCounter:	equ os_SystemVariables + 16
   217                              <1> os_PacketAddress:	equ os_SystemVariables + 24
   218                              <1> os_StackBase:		equ os_SystemVariables + 40
   219                              <1> os_net_transmit:	equ os_SystemVariables + 48
   220                              <1> os_net_poll:		equ os_SystemVariables + 56
   221                              <1> os_net_ackint:		equ os_SystemVariables + 64
   222                              <1> os_NetIOBaseMem:	equ os_SystemVariables + 72
   223                              <1> os_NetMAC:		equ os_SystemVariables + 80
   224                              <1> os_HPETAddress:		equ os_SystemVariables + 88
   225                              <1> ahci_base:		equ os_SystemVariables + 96
   226                              <1> os_NetworkCallback:	equ os_SystemVariables + 104
   227                              <1> os_KeyboardCallback:	equ os_SystemVariables + 120
   228                              <1> os_ClockCallback:	equ os_SystemVariables + 128
   229                              <1> os_net_TXBytes:		equ os_SystemVariables + 136
   230                              <1> os_net_TXPackets:	equ os_SystemVariables + 144
   231                              <1> os_net_RXBytes:		equ os_SystemVariables + 152
   232                              <1> os_net_RXPackets:	equ os_SystemVariables + 160
   233                              <1> os_hdd_BytesRead:	equ os_SystemVariables + 168
   234                              <1> os_hdd_BytesWrite:	equ os_SystemVariables + 176
   235                              <1> 
   236                              <1> 
   237                              <1> ; DD - Starting at offset 256, increments by 4
   238                              <1> os_HPETRate:		equ os_SystemVariables + 260
   239                              <1> os_MemAmount:		equ os_SystemVariables + 264	; in MiB
   240                              <1> ahci_PA:		equ os_SystemVariables + 268	; Each set bit is an active port
   241                              <1> 
   242                              <1> 
   243                              <1> ; DW - Starting at offset 512, increments by 2
   244                              <1> os_NumCores:		equ os_SystemVariables + 512
   245                              <1> os_CoreSpeed:		equ os_SystemVariables + 514
   246                              <1> os_NetIOAddress:	equ os_SystemVariables + 522
   247                              <1> os_NetLock:		equ os_SystemVariables + 524
   248                              <1> 
   249                              <1> 
   250                              <1> ; DB - Starting at offset 768, increments by 1
   251                              <1> scancode:		equ os_SystemVariables + 770
   252                              <1> key:			equ os_SystemVariables + 771
   253                              <1> key_shift:		equ os_SystemVariables + 772
   254                              <1> os_PCIEnabled:		equ os_SystemVariables + 775	; 1 if PCI is detected
   255                              <1> os_NetEnabled:		equ os_SystemVariables + 776	; 1 if a supported network card was enabled
   256                              <1> os_NetIRQ:		equ os_SystemVariables + 778	; Set to Interrupt line that NIC is connected to
   257                              <1> os_NetActivity_TX:	equ os_SystemVariables + 779
   258                              <1> os_NetActivity_RX:	equ os_SystemVariables + 780
   259                              <1> os_EthernetBuffer_C1:	equ os_SystemVariables + 781	; Counter 1 for the Ethernet RX Ring Buffer
   260                              <1> os_EthernetBuffer_C2:	equ os_SystemVariables + 782	; Counter 2 for the Ethernet RX Ring Buffer
   261                              <1> os_DiskEnabled:		equ os_SystemVariables + 783
   262                              <1> os_DiskActivity:	equ os_SystemVariables + 784
   263                              <1> 
   264                              <1> 
   265                              <1> ; Misc
   266                              <1> keylayoutlower:
   267 000017E0 000031323334353637- <1> db 0x00, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0x0e, 0, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0x1c, 0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', 0x27, '`', 0, '\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0, 0, 0, ' ', 0
   267 000017E9 3839302D3D0E007177- <1>
   267 000017F2 6572747975696F705B- <1>
   267 000017FB 5D1C00617364666768- <1>
   267 00001804 6A6B6C3B2760005C7A- <1>
   267 0000180D 786376626E6D2C2E2F- <1>
   267 00001816 0000002000          <1>
   268                              <1> keylayoutupper:
   269 0000181B 000021402324255E26- <1> db 0x00, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0x0e, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0x1c, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', 0x22, '~', 0, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0, 0, 0, ' ', 0
   269 00001824 2A28295F2B0E005157- <1>
   269 0000182D 4552545955494F507B- <1>
   269 00001836 7D1C00415344464748- <1>
   269 0000183F 4A4B4C3A227E007C5A- <1>
   269 00001848 584356424E4D3C3E3F- <1>
   269 00001851 0000002000          <1>
   270                              <1> ; 0e = backspace
   271                              <1> ; 1c = enter
   272 00001856 0000                <1> tchar: db 0, 0
   273                              <1> 
   274                              <1> 
   275                              <1> ;------------------------------------------------------------------------------
   276                              <1> 
   277                              <1> SYS64_CODE_SEL	equ 8		; defined by Pure64
   278                              <1> 
   279                              <1> ; =============================================================================
   280                              <1> ; EOF
   170                                  
   171 00001858 00<rep 7A8h>            times KERNELSIZE-($-$$) db 0		; Set the compiled kernel binary to at least this size in bytes
   172                                  
   173                                  ; =============================================================================
   174                                  ; EOF
